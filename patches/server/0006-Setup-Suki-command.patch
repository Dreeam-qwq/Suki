From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Thu, 13 Oct 2022 18:09:28 +0200
Subject: [PATCH] Setup Suki command


diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 94e5ec6b883c59a5fa6aba778803def3d7c395dd..565e042fff20cb656977c4b9a02ff3e3553678b9 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -226,6 +226,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         org.spigotmc.WatchdogThread.doStart(org.spigotmc.SpigotConfig.timeoutTime, org.spigotmc.SpigotConfig.restartOnCrash);
         thread.start(); // Paper - start console thread after MinecraftServer.console & PaperConfig are initialized
         io.papermc.paper.command.PaperCommands.registerCommands(this);
+        org.sucraft.suki.command.SukiCommands.registerCommands(this); // Suki - Suki commands
         com.destroystokyo.paper.Metrics.PaperMetrics.startMetrics();
         com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // load version history now
         io.papermc.paper.brigadier.PaperBrigadierProviderImpl.INSTANCE.getClass(); // init PaperBrigadierProvider
diff --git a/src/main/java/org/sucraft/suki/command/SukiCommand.java b/src/main/java/org/sucraft/suki/command/SukiCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..9fdacb5b7bed75631e00b05ca3df92639546f6ef
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/command/SukiCommand.java
@@ -0,0 +1,145 @@
+// Suki - /suki command
+
+package org.sucraft.suki.command;
+
+import io.papermc.paper.command.CommandUtil;
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.Util;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginManager;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.sucraft.suki.command.subcommand.ReloadCommand;
+import org.sucraft.suki.command.subcommand.VersionCommand;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+@DefaultQualifier(NonNull.class)
+public final class SukiCommand extends Command {
+    static final String BASE_PERM = "suki.command.suki.";
+    // subcommand label -> subcommand
+    private static final Map<String, SukiSubcommand> SUBCOMMANDS = Util.make(() -> {
+        final Map<Set<String>, SukiSubcommand> commands = new HashMap<>();
+
+        commands.put(Set.of("reload"), new ReloadCommand());
+        commands.put(Set.of("version"), new VersionCommand());
+
+        return commands.entrySet().stream()
+            .flatMap(entry -> entry.getKey().stream().map(s -> Map.entry(s, entry.getValue())))
+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    });
+    // alias -> subcommand label
+    private static final Map<String, String> ALIASES = Util.make(() -> {
+        final Map<String, Set<String>> aliases = new HashMap<>();
+
+        aliases.put("version", Set.of("ver"));
+
+        return aliases.entrySet().stream()
+            .flatMap(entry -> entry.getValue().stream().map(s -> Map.entry(s, entry.getKey())))
+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    });
+
+    public SukiCommand(final String name) {
+        super(name);
+        this.description = "Suki related commands";
+        this.usageMessage = "/suki [" + String.join(" | ", SUBCOMMANDS.keySet()) + "]";
+        final List<String> permissions = new ArrayList<>();
+        permissions.add("suki.command.suki");
+        permissions.addAll(SUBCOMMANDS.keySet().stream().map(s -> BASE_PERM + s).toList());
+        this.setPermission(String.join(";", permissions));
+        final PluginManager pluginManager = Bukkit.getServer().getPluginManager();
+        for (final String perm : permissions) {
+            pluginManager.addPermission(new Permission(perm, PermissionDefault.OP));
+        }
+    }
+
+    private static boolean testPermission(final CommandSender sender, final String permission) {
+        if (sender.hasPermission(BASE_PERM + permission) || sender.hasPermission("suki.command.suki")) {
+            return true;
+        }
+        sender.sendMessage(Bukkit.permissionMessage());
+        return false;
+    }
+
+    @Override
+    public List<String> tabComplete(
+        final CommandSender sender,
+        final String alias,
+        final String[] args,
+        final @Nullable Location location
+    ) throws IllegalArgumentException {
+        if (args.length <= 1) {
+            return CommandUtil.getListMatchingLast(sender, args, SUBCOMMANDS.keySet());
+        }
+
+        final @Nullable Pair<String, SukiSubcommand> subCommand = resolveCommand(args[0]);
+        if (subCommand != null) {
+            return subCommand.second().tabComplete(sender, subCommand.first(), Arrays.copyOfRange(args, 1, args.length));
+        }
+
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean execute(
+        final CommandSender sender,
+        final String commandLabel,
+        final String[] args
+    ) {
+        if (!testPermission(sender)) {
+            return true;
+        }
+
+        if (args.length == 0) {
+            sender.sendMessage(text("Usage: " + this.usageMessage, RED));
+            return false;
+        }
+        final @Nullable Pair<String, SukiSubcommand> subCommand = resolveCommand(args[0]);
+
+        if (subCommand == null) {
+            sender.sendMessage(text("Usage: " + this.usageMessage, RED));
+            return false;
+        }
+
+        if (!testPermission(sender, subCommand.first())) {
+            return true;
+        }
+        final String[] choppedArgs = Arrays.copyOfRange(args, 1, args.length);
+        return subCommand.second().execute(sender, subCommand.first(), choppedArgs);
+    }
+
+    private static @Nullable Pair<String, SukiSubcommand> resolveCommand(String label) {
+        label = label.toLowerCase(Locale.ENGLISH);
+        @Nullable SukiSubcommand subCommand = SUBCOMMANDS.get(label);
+        if (subCommand == null) {
+            final @Nullable String command = ALIASES.get(label);
+            if (command != null) {
+                label = command;
+                subCommand = SUBCOMMANDS.get(command);
+            }
+        }
+
+        if (subCommand != null) {
+            return Pair.of(label, subCommand);
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/org/sucraft/suki/command/SukiCommands.java b/src/main/java/org/sucraft/suki/command/SukiCommands.java
new file mode 100644
index 0000000000000000000000000000000000000000..01545d1ce279e199e69c09e7d8c391337e930afa
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/command/SukiCommands.java
@@ -0,0 +1,31 @@
+// Suki - Suki commands
+
+package org.sucraft.suki.command;
+
+import io.papermc.paper.command.MSPTCommand;
+import io.papermc.paper.command.PaperCommand;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.util.HashMap;
+import java.util.Map;
+
+@DefaultQualifier(NonNull.class)
+public final class SukiCommands {
+
+    private SukiCommands() {
+    }
+
+    private static final Map<String, Command> COMMANDS = new HashMap<>();
+    static {
+        COMMANDS.put("suki", new SukiCommand("suki"));
+    }
+
+    public static void registerCommands(final MinecraftServer server) {
+        COMMANDS.forEach((s, command) -> {
+            server.server.getCommandMap().register(s, "Suki", command);
+        });
+    }
+}
diff --git a/src/main/java/org/sucraft/suki/command/SukiSubcommand.java b/src/main/java/org/sucraft/suki/command/SukiSubcommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..8afaad936500b3dc7568ad57f119f1e7660a3120
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/command/SukiSubcommand.java
@@ -0,0 +1,19 @@
+// Suki - Suki commands
+
+package org.sucraft.suki.command;
+
+import org.bukkit.command.CommandSender;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.util.Collections;
+import java.util.List;
+
+@DefaultQualifier(NonNull.class)
+public interface SukiSubcommand {
+    boolean execute(CommandSender sender, String subCommand, String[] args);
+
+    default List<String> tabComplete(final CommandSender sender, final String subCommand, final String[] args) {
+        return Collections.emptyList();
+    }
+}
diff --git a/src/main/java/org/sucraft/suki/command/subcommand/ReloadCommand.java b/src/main/java/org/sucraft/suki/command/subcommand/ReloadCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..18bc7908f31897d955cf1d5a036728688c502d99
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/command/subcommand/ReloadCommand.java
@@ -0,0 +1,35 @@
+// Suki - /suki command
+
+package org.sucraft.suki.command.subcommand;
+
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftServer;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.sucraft.suki.command.SukiSubcommand;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.GREEN;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+@DefaultQualifier(NonNull.class)
+public final class ReloadCommand implements SukiSubcommand {
+    @Override
+    public boolean execute(final CommandSender sender, final String subCommand, final String[] args) {
+        this.doReload(sender);
+        return true;
+    }
+
+    private void doReload(final CommandSender sender) {
+        Command.broadcastCommandMessage(sender, text("Please note that this command is not supported and may cause issues.", RED));
+        Command.broadcastCommandMessage(sender, text("If you encounter any issues please use the /stop command to restart your server.", RED));
+
+        MinecraftServer server = ((CraftServer) sender.getServer()).getServer();
+        server.sukiConfigurations.reloadConfigs(server);
+        server.server.reloadCount++;
+
+        Command.broadcastCommandMessage(sender, text("Suki config reload complete.", GREEN));
+    }
+}
diff --git a/src/main/java/org/sucraft/suki/command/subcommand/VersionCommand.java b/src/main/java/org/sucraft/suki/command/subcommand/VersionCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..da669f80719df48260a43cfa616d3d05f325374a
--- /dev/null
+++ b/src/main/java/org/sucraft/suki/command/subcommand/VersionCommand.java
@@ -0,0 +1,23 @@
+// Suki - /suki command
+
+package org.sucraft.suki.command.subcommand;
+
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.sucraft.suki.command.SukiSubcommand;
+
+@DefaultQualifier(NonNull.class)
+public final class VersionCommand implements SukiSubcommand {
+    @Override
+    public boolean execute(final CommandSender sender, final String subCommand, final String[] args) {
+        final @Nullable Command ver = MinecraftServer.getServer().server.getCommandMap().getCommand("version");
+        if (ver != null) {
+            ver.execute(sender, "suki", me.titaniumtown.Constants.EMPTY_string_arr); // JettPack
+        }
+        return true;
+    }
+}
