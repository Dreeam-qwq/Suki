From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Fri, 10 Jun 2022 00:26:10 +0200
Subject: [PATCH] Per-player load, see and track view distance


diff --git a/src/main/java/co/aikar/timings/TimingsExport.java b/src/main/java/co/aikar/timings/TimingsExport.java
index 4bf254202da3a41c4179922a3533a816f8763f85..4e006a6d1f00846175c00db189e66b330b515bfb 100644
--- a/src/main/java/co/aikar/timings/TimingsExport.java
+++ b/src/main/java/co/aikar/timings/TimingsExport.java
@@ -166,8 +166,11 @@ public class TimingsExport extends Thread {
                 })),
                 // Paper start - replace chunk loader system
                 pair("ticking-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance()),
-                pair("no-ticking-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance()),
-                pair("sending-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance())
+                // Suki start - per-player track and see view distance
+                pair("max-track-distance", world.sukiConfig().viewDistance.track.getMax()),
+                pair("max-see-distance", world.sukiConfig().viewDistance.see.getMax()),
+                pair("max-load-distance", world.sukiConfig().viewDistance.load.getMax())
+                // Suki end - per-player track and see view distance
                 // Paper end - replace chunk loader system
             ));
         }));
diff --git a/src/main/java/co/aikar/timings/WorldTimingsHandler.java b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
index fe79c0add4f7cb18d487c5bb9415c40c5b551ea2..dda0f831d0e3768f5798705695742d0c9052f963 100644
--- a/src/main/java/co/aikar/timings/WorldTimingsHandler.java
+++ b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
@@ -44,6 +44,28 @@ public class WorldTimingsHandler {
     public final Timing broadcastChunkUpdates;
     public final Timing countNaturalMobs;
 
+    // Suki start - per-player view distance
+//    public final Timing getPlayersNearChunkForSending;
+    public final Timing chunkMapPlayerMove;
+//    public final Timing chunkMapPlayerMoveUpdatePos;
+//    public final Timing chunkMapPlayerMoveUpdateDistanceManager;
+//    public final Timing chunkMapPlayerMoveUpdatePlayerMap;
+//    public final Timing chunkMapUpdatePlayerMaps;
+    public final Timing playerChunkLoaderUpdate;
+    public final Timing playerChunkLoaderUpdateGetViewDistances;
+    public final Timing playerChunkLoaderUpdateDecideWhetherToRecalculate;
+//    public final Timing chunkMapPlayerMoveUpdateChunkTrackingOrSeeing;
+//    public final Timing chunkMapPlayerMoveSortChunksForTrackAndSee;
+    public final Timing computeTrackViewDistance;
+    public final Timing computeSeeViewDistance;
+    public final Timing computeLoadViewDistance;
+    public final Timing trackViewDistanceMayHaveChanged;
+    public final Timing seeViewDistanceMayHaveChanged;
+    public final Timing loadViewDistanceMayHaveChanged;
+    public final Timing processTrackViewDistanceChange;
+    public final Timing processSeeViewDistanceChange;
+    // Suki end - per-player view distance
+
     public final Timing chunkLoad;
     public final Timing chunkLoadPopulate;
     public final Timing syncChunkLoad;
@@ -119,6 +141,27 @@ public class WorldTimingsHandler {
         broadcastChunkUpdates = Timings.ofSafe(name + "Broadcast chunk updates");
         countNaturalMobs = Timings.ofSafe(name + "Count natural mobs");
 
+        // Suki start - per-player view distance
+//        getPlayersNearChunkForSending = Timings.ofSafe("Get players near chunk for sending");
+        chunkMapPlayerMove = Timings.ofSafe("Chunk map player move");
+//        chunkMapPlayerMoveUpdatePos = Timings.ofSafe("Chunk map player move - update pos");
+//        chunkMapPlayerMoveUpdateDistanceManager = Timings.ofSafe("Chunk map player move - update distance manager");
+//        chunkMapPlayerMoveUpdatePlayerMap = Timings.ofSafe("Chunk map player move - update player map");
+//        chunkMapUpdatePlayerMaps = Timings.ofSafe("Chunk map update player maps");
+        playerChunkLoaderUpdate = Timings.ofSafe("PlayerChunkLoader update");
+        playerChunkLoaderUpdateGetViewDistances = Timings.ofSafe("PlayerChunkLoader update - get view distances");
+        playerChunkLoaderUpdateDecideWhetherToRecalculate = Timings.ofSafe("PlayerChunkLoader update - decide whether to recalculate");
+//        chunkMapPlayerMoveUpdateChunkTrackingOrSeeing = Timings.ofSafe("Chunk map player move - update chunk tracking or seeing");
+//        chunkMapPlayerMoveSortChunksForTrackAndSee = Timings.ofSafe("Chunk map player move - sort chunks for track and see");
+        computeTrackViewDistance = Timings.ofSafe("Compute track view distance");
+        computeSeeViewDistance = Timings.ofSafe("Compute see view distance");
+        computeLoadViewDistance = Timings.ofSafe("Compute load view distance");
+        trackViewDistanceMayHaveChanged = Timings.ofSafe("Track view distance may have changed");
+        seeViewDistanceMayHaveChanged = Timings.ofSafe("See view distance may have changed");
+        loadViewDistanceMayHaveChanged = Timings.ofSafe("Load view distance may have changed");
+        processTrackViewDistanceChange = Timings.ofSafe("Process track view distance change");
+        processSeeViewDistanceChange = Timings.ofSafe("Process see view distance change");
+        // Suki end - per-player view distance
 
         miscMobSpawning = Timings.ofSafe(name + "Mob spawning - Misc");
 
diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index 5ecdbeb90e9715fc89ff25e9b3c33a2e8d98ff93..2470f8fa111d60e7f106510783ccc2a18e52756f 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -24,6 +24,7 @@ import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.entity.Player;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 import java.util.TreeSet;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -49,31 +50,33 @@ public final class PlayerChunkLoader {
         return data.getTargetTickViewDistance();
     }
 
-    public static int getLoadViewDistance(final Player player) {
-        return getLoadViewDistance(((CraftPlayer)player).getHandle());
-    }
-
-    public static int getLoadViewDistance(final ServerPlayer player) {
-        final ServerLevel level = (ServerLevel)player.level;
-        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
-        if (data == null) {
-            return level.chunkSource.chunkMap.playerChunkManager.getLoadDistance();
-        }
-        return data.getLoadDistance();
-    }
-
-    public static int getSendViewDistance(final Player player) {
-        return getSendViewDistance(((CraftPlayer)player).getHandle());
-    }
-
-    public static int getSendViewDistance(final ServerPlayer player) {
-        final ServerLevel level = (ServerLevel)player.level;
-        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
-        if (data == null) {
-            return level.chunkSource.chunkMap.playerChunkManager.getTargetSendDistance();
-        }
-        return data.getTargetSendViewDistance();
-    }
+    // Suki start - per-player view distance
+//    public static int getLoadViewDistance(final Player player) {
+//        return getLoadViewDistance(((CraftPlayer)player).getHandle());
+//    }
+//
+//    public static int getLoadViewDistance(final ServerPlayer player) {
+//        final ServerLevel level = (ServerLevel)player.level;
+//        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
+//        if (data == null) {
+//            return level.chunkSource.chunkMap.playerChunkManager.getLoadDistance();
+//        }
+//        return data.getLoadDistance();
+//    }
+
+//    public static int getSendViewDistance(final Player player) {
+//        return getSendViewDistance(((CraftPlayer)player).getHandle());
+//    }
+//
+//    public static int getSendViewDistance(final ServerPlayer player) {
+//        final ServerLevel level = (ServerLevel)player.level;
+//        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
+//        if (data == null) {
+//            return level.chunkSource.chunkMap.playerChunkManager.getTargetSendDistance();
+//        }
+//        return data.getTargetSendViewDistance();
+//    }
+    // Suki end - per-player view distance
 
     protected final ChunkMap chunkMap;
     protected final Reference2ObjectLinkedOpenHashMap<ServerPlayer, PlayerLoaderData> playerMap = new Reference2ObjectLinkedOpenHashMap<>(512, 0.7f);
@@ -135,7 +138,15 @@ public final class PlayerChunkLoader {
     /**
      * The chunks to be sent to players, provided they're send-ready. Send-ready means the chunk and its 1 radius neighbours are loaded.
      */
-    public final PlayerAreaMap broadcastMap;
+    // Suki start - per-player track and see view distance
+    public final PlayerAreaMap broadcastMapForTracking;
+    public final PlayerAreaMap broadcastMapForSeeing;
+
+    public PlayerAreaMap getBroadcastMap(final boolean concernsTracking) {
+        return concernsTracking ? this.broadcastMapForTracking : this.broadcastMapForSeeing;
+    }
+
+    // Suki end - per-player track and see view distance
 
     /**
      * The chunks to be brought up to send-ready status. Send-ready means the chunk and its 1 radius neighbours are loaded.
@@ -153,15 +164,17 @@ public final class PlayerChunkLoader {
      */
     public final PlayerAreaMap tickMap;
 
-    /**
-     * -1 if defaulting to [load distance], else always in [2, load distance]
-     */
-    protected int rawSendDistance = -1;
-
-    /**
-     * -1 if defaulting to [tick view distance + 1], else always in [tick view distance + 1, 32 + 1]
-     */
-    protected int rawLoadDistance = -1;
+    // Suki start - per-player view distance
+//    /**
+//     * -1 if defaulting to [load distance], else always in [2, load distance]
+//     */
+//    protected int rawSendDistance = -1;
+//
+//    /**
+//     * -1 if defaulting to [tick view distance + 1], else always in [tick view distance + 1, 32 + 1]
+//     */
+//    protected int rawLoadDistance = -1;
+    // Suki end - per-player view distance
 
     /**
      * Never -1, always in [2, 32]
@@ -178,47 +191,49 @@ public final class PlayerChunkLoader {
         this.setTickDistance(distance);
     }
 
-    public int getTargetNoTickViewDistance() {
-        return this.getLoadDistance() - 1;
-    }
-
-    public void setTargetNoTickViewDistance(final int distance) {
-        this.setLoadDistance(distance == -1 ? -1 : distance + 1);
-    }
-
-    public int getTargetSendDistance() {
-        return this.rawSendDistance == -1 ? this.getLoadDistance() : this.rawSendDistance;
-    }
-
-    public void setTargetSendDistance(final int distance) {
-        this.setSendDistance(distance);
-    }
-
-    // internal methods
-
-    public int getSendDistance() {
-        final int loadDistance = this.getLoadDistance();
-        return this.rawSendDistance == -1 ? loadDistance : Math.min(this.rawSendDistance, loadDistance);
-    }
-
-    public void setSendDistance(final int distance) {
-        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-            throw new IllegalArgumentException("Send distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
-        }
-        this.rawSendDistance = distance;
-    }
-
-    public int getLoadDistance() {
-        final int tickDistance = this.getTickDistance();
-        return this.rawLoadDistance == -1 ? tickDistance + 1 : Math.max(tickDistance + 1, this.rawLoadDistance);
-    }
-
-    public void setLoadDistance(final int distance) {
-        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-            throw new IllegalArgumentException("Load distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
-        }
-        this.rawLoadDistance = distance;
-    }
+    // Suki start - per-player view distance
+//    public int getTargetNoTickViewDistance() {
+//        return this.getLoadDistance() - 1;
+//    }
+//
+//    public void setTargetNoTickViewDistance(final int distance) {
+//        this.setLoadDistance(distance == -1 ? -1 : distance + 1);
+//    }
+//
+//    public int getTargetSendDistance() {
+//        return this.rawSendDistance == -1 ? this.getLoadDistance() : this.rawSendDistance;
+//    }
+//
+//    public void setTargetSendDistance(final int distance) {
+//        this.setSendDistance(distance);
+//    }
+//
+//    // internal methods
+//
+//    public int getSendDistance() {
+//        final int loadDistance = this.getLoadDistance();
+//        return this.rawSendDistance == -1 ? loadDistance : Math.min(this.rawSendDistance, loadDistance);
+//    }
+//
+//    public void setSendDistance(final int distance) {
+//        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
+//            throw new IllegalArgumentException("Send distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
+//        }
+//        this.rawSendDistance = distance;
+//    }
+//
+//    public int getLoadDistance() {
+//        final int tickDistance = this.getTickDistance();
+//        return this.rawLoadDistance == -1 ? tickDistance + 1 : Math.max(tickDistance + 1, this.rawLoadDistance);
+//    }
+//
+//    public void setLoadDistance(final int distance) {
+//        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
+//            throw new IllegalArgumentException("Load distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
+//        }
+//        this.rawLoadDistance = distance;
+//    }
+    // Suki end - per-player view distance
 
     public int getTickDistance() {
         return this.rawTickDistance;
@@ -256,12 +271,20 @@ public final class PlayerChunkLoader {
 
     public PlayerChunkLoader(final ChunkMap chunkMap, final PooledLinkedHashSets<ServerPlayer> pooledHashSets) {
         this.chunkMap = chunkMap;
-        this.broadcastMap = new PlayerAreaMap(pooledHashSets,
+        // Suki start - player track and see view distance
+        this.broadcastMapForTracking = new PlayerAreaMap(pooledHashSets,
+                null,
+                (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ, true);
+                });
+        this.broadcastMapForSeeing = new PlayerAreaMap(pooledHashSets,
                 null,
                 (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
                  com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
-                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ);
+                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ, false);
                 });
+        // Suki end - player track and see view distance
         this.loadMap = new PlayerAreaMap(pooledHashSets,
                 null,
                 (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
@@ -311,12 +334,16 @@ public final class PlayerChunkLoader {
     protected final LongOpenHashSet isTargetedForPlayerLoad = new LongOpenHashSet();
     protected final LongOpenHashSet chunkTicketTracker = new LongOpenHashSet();
 
-    public boolean isChunkNearPlayers(final int chunkX, final int chunkZ) {
-        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.broadcastMap.getObjectsInRange(chunkX, chunkZ);
+    // Suki start - per-player track and see view distance
+
+    public boolean isChunkNearPlayers(final int chunkX, final int chunkZ, boolean concernsTracking) {
+        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.getBroadcastMap(concernsTracking).getObjectsInRange(chunkX, chunkZ);
 
         return playersInSendRange != null;
     }
 
+    // Suki end - per-player track and see view distance
+
     public void onChunkPostProcessing(final int chunkX, final int chunkZ) {
         this.onChunkSendReady(chunkX, chunkZ);
     }
@@ -348,34 +375,38 @@ public final class PlayerChunkLoader {
         return levelChunk != null && levelChunk.isPostProcessingDone && this.isTargetedForPlayerLoad.contains(key);
     }
 
-    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean borderOnly) {
-        return borderOnly ? this.isChunkSentBorderOnly(player, chunkX, chunkZ) : this.isChunkSent(player, chunkX, chunkZ);
+    // Suki start - per-player track and see view distance
+
+    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean borderOnly, final boolean concernsTracking) {
+        return borderOnly ? this.isChunkSentBorderOnly(player, chunkX, chunkZ, concernsTracking) : this.isChunkSent(player, chunkX, chunkZ, concernsTracking);
     }
 
-    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) {
         final PlayerLoaderData data = this.playerMap.get(player);
         if (data == null) {
             return false;
         }
 
-        return data.hasSentChunk(chunkX, chunkZ);
+        return data.hasSentChunk(chunkX, chunkZ, concernsTracking);
     }
 
-    public boolean isChunkSentBorderOnly(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public boolean isChunkSentBorderOnly(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) {
         final PlayerLoaderData data = this.playerMap.get(player);
         if (data == null) {
             return false;
         }
 
-        final boolean center = data.hasSentChunk(chunkX, chunkZ);
+        final boolean center = data.hasSentChunk(chunkX, chunkZ, concernsTracking);
         if (!center) {
             return false;
         }
 
-        return !(data.hasSentChunk(chunkX - 1, chunkZ) && data.hasSentChunk(chunkX + 1, chunkZ) &&
-            data.hasSentChunk(chunkX, chunkZ - 1) && data.hasSentChunk(chunkX, chunkZ + 1));
+        return !(data.hasSentChunk(chunkX - 1, chunkZ, concernsTracking) && data.hasSentChunk(chunkX + 1, chunkZ, concernsTracking) &&
+            data.hasSentChunk(chunkX, chunkZ - 1, concernsTracking) && data.hasSentChunk(chunkX, chunkZ + 1, concernsTracking));
     }
 
+    // Suki end - per-player track and see view distance
+
     protected int getMaxConcurrentChunkSends() {
         return GlobalConfiguration.get().chunkLoading.maxConcurrentSends;
     }
@@ -400,47 +431,55 @@ public final class PlayerChunkLoader {
     }
 
     public void onChunkSendReady(final int chunkX, final int chunkZ) {
-        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.broadcastMap.getObjectsInRange(chunkX, chunkZ);
 
-        if (playersInSendRange == null) {
-            return;
-        }
+        // Suki start - per-player track and see view distance
 
-        final Object[] rawData = playersInSendRange.getBackingSet();
-        for (int i = 0, len = rawData.length; i < len; ++i) {
-            final Object raw = rawData[i];
+        for (boolean concernsTracking : new boolean[] {false, true}) {
+            final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.getBroadcastMap(concernsTracking).getObjectsInRange(chunkX, chunkZ);
 
-            if (!(raw instanceof ServerPlayer)) {
-                continue;
+            if (playersInSendRange == null) {
+                return;
+            }
+
+            final Object[] rawData = playersInSendRange.getBackingSet();
+            for (int i = 0, len = rawData.length; i < len; ++i) {
+                final Object raw = rawData[i];
+
+                if (!(raw instanceof ServerPlayer)) {
+                    continue;
+                }
+                this.onChunkSendReady((ServerPlayer) raw, chunkX, chunkZ, concernsTracking);
             }
-            this.onChunkSendReady((ServerPlayer)raw, chunkX, chunkZ);
         }
+
+        // Suki end - per-player track and see view distance
+
     }
 
-    public void onChunkSendReady(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public void onChunkSendReady(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) { // Suki - per-player track and see view distance
         final PlayerLoaderData data = this.playerMap.get(player);
 
         if (data == null) {
             return;
         }
 
-        if (data.hasSentChunk(chunkX, chunkZ) || !this.isChunkPlayerLoaded(chunkX, chunkZ)) {
+        if (data.hasSentChunk(chunkX, chunkZ, concernsTracking) || !this.isChunkPlayerLoaded(chunkX, chunkZ)) { // Suki - per-player track and see view distance
             // if we don't have player tickets, then the load logic will pick this up and queue to send
             return;
         }
 
-        if (!data.chunksToBeSent.remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        if (!data.getChunksToBeSent(concernsTracking).remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) { // Suki - per-player track and see view distance
             // don't queue to send, we don't want the chunk
             return;
         }
 
-        final long playerPos = this.broadcastMap.getLastCoordinate(player);
+        final long playerPos = this.broadcastMapForSeeing.getLastCoordinate(player); // Suki - per-player track and see view distance
         final int playerChunkX = CoordinateUtils.getChunkX(playerPos);
         final int playerChunkZ = CoordinateUtils.getChunkZ(playerPos);
         final int manhattanDistance = Math.abs(playerChunkX - chunkX) + Math.abs(playerChunkZ - chunkZ);
 
         final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, 0.0);
-        data.sendQueue.add(holder);
+        data.getSendQueue(concernsTracking).add(holder); // Suki - per-player track and see view distance
     }
 
     public void onChunkLoad(final int chunkX, final int chunkZ) {
@@ -449,14 +488,14 @@ public final class PlayerChunkLoader {
         }
     }
 
-    public void onChunkLeave(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public void onChunkLeave(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) { // Suki - per-player track and see view distance
         final PlayerLoaderData data = this.playerMap.get(player);
 
         if (data == null) {
             return;
         }
 
-        data.unloadChunk(chunkX, chunkZ);
+        data.unloadChunk(chunkX, chunkZ, concernsTracking); // Suki - per-player track and see view distance
     }
 
     public void addPlayer(final ServerPlayer player) {
@@ -466,7 +505,7 @@ public final class PlayerChunkLoader {
         }
         final PlayerLoaderData data = new PlayerLoaderData(player, this);
         if (this.playerMap.putIfAbsent(player, data) == null) {
-            data.update();
+            data.update(true); // Suki - per-player view distance
         }
     }
 
@@ -492,14 +531,14 @@ public final class PlayerChunkLoader {
         }
     }
 
-    public void updatePlayer(final ServerPlayer player) {
+    public void updatePlayer(final ServerPlayer player, boolean recalculateMapsIfOnlyViewDistanceChanged) { // Suki - per-player view distance
         TickThread.ensureTickThread("Cannot update player async");
         if (!player.isRealPlayer) {
             return;
         }
         final PlayerLoaderData loaderData = this.playerMap.get(player);
         if (loaderData != null) {
-            loaderData.update();
+            loaderData.update(recalculateMapsIfOnlyViewDistanceChanged); // Suki - per-player view distance
         }
     }
 
@@ -510,7 +549,7 @@ public final class PlayerChunkLoader {
     public void tick() {
         TickThread.ensureTickThread("Cannot tick async");
         for (final PlayerLoaderData data : this.playerMap.values()) {
-            data.update();
+            data.update(true); // Suki - per-player view distance
         }
         this.tickMidTick();
     }
@@ -559,7 +598,14 @@ public final class PlayerChunkLoader {
 
             final PlayerLoaderData data = this.chunkSendQueue.removeFirst();
 
-            final ChunkPriorityHolder queuedSend = data.sendQueue.pollFirst();
+            // Suki start - per-player track and see view distance
+            ChunkPriorityHolder queuedSend = data.getSendQueue(true).pollFirst();
+            boolean concernsTracking = true;
+            if (queuedSend == null) {
+                queuedSend = data.getSendQueue(false).pollFirst();
+                concernsTracking = false;
+            }
+            // Suki end - per-player track and see view distance
             if (queuedSend == null) {
                 concurrentChunkSends.getAndDecrement(); // we never sent, so decrease
                 // stop iterating over players who have nothing to send
@@ -596,7 +642,7 @@ public final class PlayerChunkLoader {
                 }
 
                 concurrentChunkSends.getAndDecrement();
-            });
+            }, concernsTracking);
 
             nextChunkSend = this.getMaxSendAddend() + time;
             if (time < nextChunkSend) {
@@ -776,7 +822,10 @@ public final class PlayerChunkLoader {
         // this is corrected so that 0 is along the positive x-axis
         protected float lastYaw = Float.NEGATIVE_INFINITY;
 
-        protected int lastSendDistance = Integer.MIN_VALUE;
+        // Suki start - per-player track and see view distance
+        protected int lastTrackDistance = Integer.MIN_VALUE;
+        protected int lastSeeDistance = Integer.MIN_VALUE;
+        // Suki end - per-player track and see view distance
         protected int lastLoadDistance = Integer.MIN_VALUE;
         protected int lastTickDistance = Integer.MIN_VALUE;
         protected boolean usingLookingPriority;
@@ -787,28 +836,29 @@ public final class PlayerChunkLoader {
         // warning: modifications of this field must be aware that the loadQueue inside PlayerChunkLoader uses this field
         // in a comparator!
         protected final ArrayDeque<ChunkPriorityHolder> loadQueue = new ArrayDeque<>();
-        protected final LongOpenHashSet sentChunks = new LongOpenHashSet();
-        protected final LongOpenHashSet chunksToBeSent = new LongOpenHashSet();
 
-        protected final TreeSet<ChunkPriorityHolder> sendQueue = new TreeSet<>((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
-            final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
-            if (distanceCompare != 0) {
-                return distanceCompare;
-            }
+        // Suki start - per-player view distance
 
-            final int coordinateXCompare = Integer.compare(p1.chunkX, p2.chunkX);
-            if (coordinateXCompare != 0) {
-                return coordinateXCompare;
-            }
+        protected final LongOpenHashSet sentChunksForTracking = new LongOpenHashSet();
+        protected final LongOpenHashSet chunksToBeSentForTracking = new LongOpenHashSet();
 
-            return Integer.compare(p1.chunkZ, p2.chunkZ);
-        });
+        protected final LongOpenHashSet sentChunksForSeeing = new LongOpenHashSet();
+        protected final LongOpenHashSet chunksToBeSentForSeeing = new LongOpenHashSet();
 
-        protected int sendViewDistance = -1;
-        protected int loadViewDistance = -1;
-        protected int tickViewDistance = -1;
+        private TreeSet<ChunkPriorityHolder> createSendQueue() {
+            return new TreeSet<>((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
+                final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
+                if (distanceCompare != 0) {
+                    return distanceCompare;
+                }
 
-        protected long nextChunkSendTarget;
+                final int coordinateXCompare = Integer.compare(p1.chunkX, p2.chunkX);
+                if (coordinateXCompare != 0) {
+                    return coordinateXCompare;
+                }
+                return Integer.compare(p1.chunkZ, p2.chunkZ);
+            });
+        }
 
         // this interval prevents bursting a lot of chunk loads
         protected final IntervalledCounter ticketAdditionCounterShort = new IntervalledCounter((long)(1.0e6 * 50.0)); // 50ms
@@ -822,35 +872,59 @@ public final class PlayerChunkLoader {
             this.loader = loader;
         }
 
-        // these view distance methods are for api
-        public int getTargetSendViewDistance() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
-            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
-            final int clientViewDistance = this.getClientViewDistance();
-            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!GlobalConfiguration.get().chunkLoading.autoconfigSendDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
-            return sendViewDistance;
-        }
+        protected final TreeSet<ChunkPriorityHolder> sendQueueForTracking = createSendQueue();
+        protected final TreeSet<ChunkPriorityHolder> sendQueueForSeeing = createSendQueue();
 
-        public void setTargetSendViewDistance(final int distance) {
-            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-                throw new IllegalArgumentException("Send view distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + " or -1, got: " + distance);
-            }
-            this.sendViewDistance = distance;
+        protected LongOpenHashSet getSentChunks(final boolean concernsTracking) {
+            return concernsTracking ? this.sentChunksForTracking : this.sentChunksForSeeing;
         }
-
-        public int getTargetNoTickViewDistance() {
-            return (this.loadViewDistance == -1 ? this.getLoadDistance() : this.loadViewDistance) - 1;
+        protected LongOpenHashSet getChunksToBeSent(final boolean concernsTracking) {
+            return concernsTracking ? this.chunksToBeSentForTracking : this.chunksToBeSentForSeeing;
         }
 
-        public void setTargetNoTickViewDistance(final int distance) {
-            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE)) {
-                throw new IllegalArgumentException("Simulation distance must be a number between " + MIN_VIEW_DISTANCE + " and " + MAX_VIEW_DISTANCE + " or -1, got: " + distance);
-            }
-            this.loadViewDistance = distance == -1 ? -1 : distance + 1;
+        protected TreeSet<ChunkPriorityHolder> getSendQueue(final boolean concernsTracking) {
+            return concernsTracking ? this.sendQueueForTracking : this.sendQueueForSeeing;
         }
 
+//        protected int sendViewDistance = -1;
+//        protected int loadViewDistance = -1;
+        public int tickViewDistance = -1;
+
+        protected long nextChunkSendTarget;
+
+//        // these view distance methods are for api
+//        public int getTargetSendViewDistance() {
+//            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+//            final int clientViewDistance = this.getClientViewDistance();
+//            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!PaperConfig.playerAutoConfigureSendViewDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+//            return sendViewDistance;
+//        }
+//
+//        public void setTargetSendViewDistance(final int distance) {
+//            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
+//                throw new IllegalArgumentException("Send view distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + " or -1, got: " + distance);
+//            }
+//            this.sendViewDistance = distance;
+//        }
+//
+//        public int getTargetNoTickViewDistance() {
+//            return (this.loadViewDistance == -1 ? this.getLoadDistance() : this.loadViewDistance) - 1;
+//        }
+//
+//        public void setTargetNoTickViewDistance(final int distance) {
+//            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE)) {
+//                throw new IllegalArgumentException("Simulation distance must be a number between " + MIN_VIEW_DISTANCE + " and " + MAX_VIEW_DISTANCE + " or -1, got: " + distance);
+//            }
+//            this.loadViewDistance = distance == -1 ? -1 : distance + 1;
+//        }
+
+        // Suki end - per-player view distance
+
         public int getTargetTickViewDistance() {
-            return this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+            // Suki start - per-player load distance
+            return player.getTickingViewDistance();
+            // Suki end - per-player load distance
         }
 
         public void setTargetTickViewDistance(final int distance) {
@@ -860,33 +934,37 @@ public final class PlayerChunkLoader {
             this.tickViewDistance = distance;
         }
 
-        protected int getLoadDistance() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//        protected int getLoadDistance() {
+//            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//
+//            return Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+//        }
 
-            return Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
-        }
+        // Suki start - per-player view distance
 
-        public boolean hasSentChunk(final int chunkX, final int chunkZ) {
-            return this.sentChunks.contains(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        public boolean hasSentChunk(final int chunkX, final int chunkZ, final boolean concernsTracking) {
+            return this.getSentChunks(concernsTracking).contains(CoordinateUtils.getChunkKey(chunkX, chunkZ));
         }
 
-        public void sendChunk(final int chunkX, final int chunkZ, final Runnable onChunkSend) {
-            if (this.sentChunks.add(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        public void sendChunk(final int chunkX, final int chunkZ, final Runnable onChunkSend, final boolean concernsTracking) {
+            if (this.getSentChunks(concernsTracking).add(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
                 this.player.getLevel().getChunkSource().chunkMap.updateChunkTracking(this.player,
-                        new ChunkPos(chunkX, chunkZ), new MutableObject<>(), false, true); // unloaded, loaded
+                        new ChunkPos(chunkX, chunkZ), new MutableObject<>(), false, true, concernsTracking); // unloaded, loaded
                 this.player.connection.connection.execute(onChunkSend);
             } else {
                 throw new IllegalStateException();
             }
         }
 
-        public void unloadChunk(final int chunkX, final int chunkZ) {
-            if (this.sentChunks.remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        public void unloadChunk(final int chunkX, final int chunkZ, final boolean concernsTracking) {
+            if (this.getSentChunks(concernsTracking).remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
                 this.player.getLevel().getChunkSource().chunkMap.updateChunkTracking(this.player,
-                        new ChunkPos(chunkX, chunkZ), null, true, false); // unloaded, loaded
+                        new ChunkPos(chunkX, chunkZ), null, true, false, concernsTracking); // unloaded, loaded
             }
         }
 
+        // Suki end - per-player view distance
+
         protected static boolean wantChunkLoaded(final int centerX, final int centerZ, final int chunkX, final int chunkZ,
                                                  final int sendRadius) {
             // expect sendRadius to be = 1 + target viewable radius
@@ -928,7 +1006,10 @@ public final class PlayerChunkLoader {
         }
 
         public void remove() {
-            this.loader.broadcastMap.remove(this.player);
+            // Suki start - per-player track and see view distance
+            this.loader.getBroadcastMap(false).remove(this.player);
+            this.loader.getBroadcastMap(true).remove(this.player);
+            // Suki end - per-player track and see view distance
             this.loader.loadMap.remove(this.player);
             this.loader.loadTicketCleanup.remove(this.player);
             this.loader.tickMap.remove(this.player);
@@ -938,13 +1019,20 @@ public final class PlayerChunkLoader {
             return this.player.clientViewDistance == null ? -1 : Math.max(0, this.player.clientViewDistance.intValue());
         }
 
-        public void update() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+        // Suki start - per-player view distance
+        public void update(boolean recalculateMapsIfOnlyViewDistanceChanged) { // Only recalculate the chunk loading maps if only the view distance changed in specific scenarios (world change, tick) and not every time the player moves (in which case we will still update the chunk loading maps if the player moved to a different chunk, of course)
+            this.player.level.timings.playerChunkLoaderUpdate.startTiming(); try {
+            this.player.level.timings.playerChunkLoaderUpdateGetViewDistances.startTiming();
+            final int loadViewDistance = this.player.getLoadViewDistance();
             // load view cannot be less-than tick view + 1
-            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+            final int tickViewDistance = this.player.getTickingViewDistance();
             // send view cannot be greater-than load view
             final int clientViewDistance = this.getClientViewDistance();
-            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!GlobalConfiguration.get().chunkLoading.autoconfigSendDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+//            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!GlobalConfiguration.get().chunkLoading.autoconfigSendDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+            final int trackViewDistance = this.player.getTrackViewDistance();
+            final int seeViewDistance = this.player.getSeeViewDistance();
+            this.player.level.timings.playerChunkLoaderUpdateGetViewDistances.stopTiming();
+            // Suki end - per-player view distance
 
             final double posX = this.player.getX();
             final double posZ = this.player.getZ();
@@ -957,11 +1045,14 @@ public final class PlayerChunkLoader {
             // make sure we're in the send queue
             this.loader.chunkSendWaitQueue.add(this);
 
+            this.player.level.timings.playerChunkLoaderUpdateDecideWhetherToRecalculate.startTiming(); try { // Suki - per-player view distance
             if (
                 // has view distance stayed the same?
-                    sendViewDistance == this.lastSendDistance
+                // Suki start - per-player view distance
+                (!recalculateMapsIfOnlyViewDistanceChanged || (trackViewDistance == this.lastTrackDistance && seeViewDistance == this.lastSeeDistance // Suki - per-player track and see view distance
                             && loadViewDistance == this.lastLoadDistance
-                            && tickViewDistance == this.lastTickDistance
+                            && tickViewDistance == this.lastTickDistance))
+                        // Suki end - per-player view distance
 
                             && (this.usingLookingPriority ? (
                                     // has our block stayed the same (this also accounts for chunk change)?
@@ -982,21 +1073,26 @@ public final class PlayerChunkLoader {
                 // nothing we care about changed, so we're not re-calculating
                 return;
             }
+            } finally { this.player.level.timings.playerChunkLoaderUpdateDecideWhetherToRecalculate.stopTiming(); }  // Suki - per-player view distance
 
             final int centerChunkX = Mth.floor(posX) >> 4;
             final int centerChunkZ = Mth.floor(posZ) >> 4;
 
             final boolean needsChunkCenterUpdate = (centerChunkX != this.lastChunkX) || (centerChunkZ != this.lastChunkZ);
-            this.loader.broadcastMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, sendViewDistance);
+
+            // Suki start - per-player track and see view distance
+            this.loader.getBroadcastMap(false).addOrUpdate(this.player, centerChunkX, centerChunkZ, seeViewDistance);
+            this.loader.getBroadcastMap(true).addOrUpdate(this.player, centerChunkX, centerChunkZ, trackViewDistance);
+            // Suki end - per-player track and see view distance
             this.loader.loadMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, loadViewDistance);
             this.loader.loadTicketCleanup.addOrUpdate(this.player, centerChunkX, centerChunkZ, loadViewDistance + 1);
             this.loader.tickMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, tickViewDistance);
 
-            if (sendViewDistance != this.lastSendDistance) {
+            if (seeViewDistance != this.lastSeeDistance) { // Suki - per-player track and see view distance
                 // update the view radius for client
                 // note that this should be after the map calls because the client wont expect unload calls not in its VD
                 // and it's possible we decreased VD here
-                this.player.connection.send(new ClientboundSetChunkCacheRadiusPacket(sendViewDistance));
+                this.player.connection.send(new ClientboundSetChunkCacheRadiusPacket(seeViewDistance)); // Suki - per-player track and see view distance
             }
             if (tickViewDistance != this.lastTickDistance) {
                 this.player.connection.send(new ClientboundSetSimulationDistancePacket(tickViewDistance));
@@ -1005,7 +1101,10 @@ public final class PlayerChunkLoader {
             this.lastLocX = posX;
             this.lastLocZ = posZ;
             this.lastYaw = yaw;
-            this.lastSendDistance = sendViewDistance;
+            // Suki start - per-player track and see view distance
+            this.lastTrackDistance = trackViewDistance;
+            this.lastSeeDistance = seeViewDistance;
+            // Suki start - per-player track and see view distance
             this.lastLoadDistance = loadViewDistance;
             this.lastTickDistance = tickViewDistance;
             this.usingLookingPriority = useLookPriority;
@@ -1035,76 +1134,87 @@ public final class PlayerChunkLoader {
 
             final List<ChunkPriorityHolder> loadQueue = new ArrayList<>();
 
+            // Suki start - per-player track and see view distance
+
             // clear send queue, we are re-sorting
-            this.sendQueue.clear();
+            this.getSendQueue(false).clear();
+            this.getSendQueue(true).clear();
             // clear chunk want set, vd/position might have changed
-            this.chunksToBeSent.clear();
-
-            final int searchViewDistance = Math.max(loadViewDistance, sendViewDistance);
-
-            for (int dx = -searchViewDistance; dx <= searchViewDistance; ++dx) {
-                for (int dz = -searchViewDistance; dz <= searchViewDistance; ++dz) {
-                    final int chunkX = dx + centerChunkX;
-                    final int chunkZ = dz + centerChunkZ;
-                    final int squareDistance = Math.max(Math.abs(dx), Math.abs(dz));
-                    final boolean sendChunk = squareDistance <= sendViewDistance && wantChunkLoaded(centerChunkX, centerChunkZ, chunkX, chunkZ, sendViewDistance);
-
-                    if (this.hasSentChunk(chunkX, chunkZ)) {
-                        // already sent (which means it is also loaded)
-                        if (!sendChunk) {
-                            // have sent the chunk, but don't want it anymore
-                            // unload it now
-                            this.unloadChunk(chunkX, chunkZ);
+            this.getChunksToBeSent(false).clear();
+            this.getChunksToBeSent(true).clear();
+
+            for (boolean concernsTracking : new boolean[] {false, true}) {
+
+                final int sendViewDistance = concernsTracking ? trackViewDistance : seeViewDistance;
+
+                final int searchViewDistance = Math.max(loadViewDistance, sendViewDistance);
+
+                for (int dx = -searchViewDistance; dx <= searchViewDistance; ++dx) {
+                    for (int dz = -searchViewDistance; dz <= searchViewDistance; ++dz) {
+                        final int chunkX = dx + centerChunkX;
+                        final int chunkZ = dz + centerChunkZ;
+                        final int squareDistance = Math.max(Math.abs(dx), Math.abs(dz));
+                        final boolean sendChunk = squareDistance <= sendViewDistance && wantChunkLoaded(centerChunkX, centerChunkZ, chunkX, chunkZ, sendViewDistance);
+
+                        if (this.hasSentChunk(chunkX, chunkZ, concernsTracking)) {
+                            // already sent (which means it is also loaded)
+                            if (!sendChunk) {
+                                // have sent the chunk, but don't want it anymore
+                                // unload it now
+                                this.unloadChunk(chunkX, chunkZ, concernsTracking);
+                            }
+                            continue;
                         }
-                        continue;
-                    }
 
-                    final boolean loadChunk = squareDistance <= loadViewDistance;
+                        final boolean loadChunk = squareDistance <= loadViewDistance;
 
-                    final boolean prioritised = useLookPriority && triangleIntersects(
+                        final boolean prioritised = useLookPriority && triangleIntersects(
                             // prioritisation triangle
                             p1x, p1z, p2x, p2z, p3x, p3z,
 
                             // center of chunk
-                            (double)((chunkX << 4) | 8), (double)((chunkZ << 4) | 8)
-                    );
+                            (double) ((chunkX << 4) | 8), (double) ((chunkZ << 4) | 8)
+                        );
 
-                    final int manhattanDistance = Math.abs(dx) + Math.abs(dz);
+                        final int manhattanDistance = Math.abs(dx) + Math.abs(dz);
 
-                    final double priority;
+                        final double priority;
 
-                    if (squareDistance <= GlobalConfiguration.get().chunkLoading.minLoadRadius) {
-                        // priority should be negative, and we also want to order it from center outwards
-                        // so we want (0,0) to be the smallest, and (minLoadedRadius,minLoadedRadius) to be the greatest
-                        priority = -((2 * GlobalConfiguration.get().chunkLoading.minLoadRadius + 1) - manhattanDistance);
-                    } else {
-                        if (prioritised) {
-                            // we don't prioritise these chunks above others because we also want to make sure some chunks
-                            // will be loaded if the player changes direction
-                            priority = (double)manhattanDistance / 6.0;
+                        if (squareDistance <= GlobalConfiguration.get().chunkLoading.minLoadRadius) {
+                            // priority should be negative, and we also want to order it from center outwards
+                            // so we want (0,0) to be the smallest, and (minLoadedRadius,minLoadedRadius) to be the greatest
+                            priority = -((2 * GlobalConfiguration.get().chunkLoading.minLoadRadius + 1) - manhattanDistance);
                         } else {
-                            priority = (double)manhattanDistance;
+                            if (prioritised) {
+                                // we don't prioritise these chunks above others because we also want to make sure some chunks
+                                // will be loaded if the player changes direction
+                                priority = (double) manhattanDistance / 6.0;
+                            } else {
+                                priority = (double) manhattanDistance;
+                            }
                         }
-                    }
 
-                    final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, priority);
+                        final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, priority);
 
-                    if (!this.loader.isChunkPlayerLoaded(chunkX, chunkZ)) {
-                        if (loadChunk) {
-                            loadQueue.add(holder);
+                        if (!this.loader.isChunkPlayerLoaded(chunkX, chunkZ)) {
+                            if (loadChunk) {
+                                loadQueue.add(holder);
+                                if (sendChunk) {
+                                    this.getChunksToBeSent(concernsTracking).add(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+                                }
+                            }
+                        } else {
+                            // loaded but not sent: so queue it!
                             if (sendChunk) {
-                                this.chunksToBeSent.add(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+                                this.getSendQueue(concernsTracking).add(holder);
                             }
                         }
-                    } else {
-                        // loaded but not sent: so queue it!
-                        if (sendChunk) {
-                            this.sendQueue.add(holder);
-                        }
                     }
                 }
             }
 
+            // Suki end - per-player track and see view distance
+
             loadQueue.sort((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
                 return Double.compare(p1.priority, p2.priority);
             });
@@ -1123,6 +1233,9 @@ public final class PlayerChunkLoader {
             if (needsChunkCenterUpdate) {
                 this.player.connection.send(new ClientboundSetChunkCacheCenterPacket(centerChunkX, centerChunkZ));
             }
+
+            } finally { this.player.level.timings.playerChunkLoaderUpdate.stopTiming(); }  // Suki - per-player view distance]
+
         }
     }
 }
diff --git a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
index 82063bc36ce21b9d47c050068b31db21ef30e163..76810d7767b1a66315b006569654c718105ab4ee 100644
--- a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
@@ -7,7 +7,6 @@ import net.kyori.adventure.text.Component;
 import net.kyori.adventure.text.format.NamedTextColor;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.game.ServerboundPlaceRecipePacket;
-import net.minecraft.server.level.ServerPlayer;
 import org.bukkit.Bukkit; // Pufferfish
 import org.checkerframework.checker.nullness.qual.Nullable;
 import org.spongepowered.configurate.objectmapping.ConfigSerializable;
diff --git a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
index 8b31f4b7937673f5b541d7fce3b8a3fd60a6e649..3f2d8196b80f214b219c230e22feb7f7801886db 100644
--- a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
@@ -29,6 +29,7 @@ import net.minecraft.Util;
 import net.minecraft.core.Holder;
 import net.minecraft.core.Registry;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.Difficulty;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.MobCategory;
@@ -38,7 +39,6 @@ import net.minecraft.world.item.Item;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.level.NaturalSpawner;
 import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
-import org.bukkit.entity.Wither;
 import org.slf4j.Logger;
 import org.spigotmc.SpigotWorldConfig;
 import org.spongepowered.configurate.objectmapping.ConfigSerializable;
diff --git a/src/main/java/net/minecraft/server/ChunkSystem.java b/src/main/java/net/minecraft/server/ChunkSystem.java
index d38beb8183470a48c4c927b78fbed243eebcfe71..5a8a338bbc30d92b8844b94edf828aaaf6316c65 100644
--- a/src/main/java/net/minecraft/server/ChunkSystem.java
+++ b/src/main/java/net/minecraft/server/ChunkSystem.java
@@ -128,13 +128,17 @@ public final class ChunkSystem {
         return level.chunkSource.chunkMap.getUnloadingChunkHolder(chunkX, chunkZ);
     }
 
-    public static int getSendViewDistance(final ServerPlayer player) {
-        return io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player);
-    }
+    // Suki start - per-player view distance
 
-    public static int getLoadViewDistance(final ServerPlayer player) {
-        return io.papermc.paper.chunk.PlayerChunkLoader.getLoadViewDistance(player);
-    }
+//    public static int getSendViewDistance(final ServerPlayer player) {
+//        return io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player);
+//    }
+//
+//    public static int getLoadViewDistance(final ServerPlayer player) {
+//        return io.papermc.paper.chunk.PlayerChunkLoader.getLoadViewDistance(player);
+//    }
+
+    // Suki start - per-player view distance
 
     public static int getTickViewDistance(final ServerPlayer player) {
         return io.papermc.paper.chunk.PlayerChunkLoader.getTickViewDistance(player);
diff --git a/src/main/java/net/minecraft/server/MCUtil.java b/src/main/java/net/minecraft/server/MCUtil.java
index 07b0b0993c01763b39d1c9a387447ec76b5de190..7c0fe8fcf57a3846fa0874fa923d5abe24c9135e 100644
--- a/src/main/java/net/minecraft/server/MCUtil.java
+++ b/src/main/java/net/minecraft/server/MCUtil.java
@@ -613,7 +613,12 @@ public final class MCUtil {
 
             worldData.addProperty("is-loaded", loadedWorlds.contains(bukkitWorld));
             worldData.addProperty("name", world.getWorld().getName());
-            worldData.addProperty("view-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance()); // Paper - replace chunk loader system
+            // Suki start - per-player view distance
+            worldData.addProperty("view-distance", world.getChunkSource().chunkMap.getVanillaWorldViewDistance()); // Paper - replace chunk loader system
+            worldData.addProperty("max-track-view-distance", world.sukiConfig().viewDistance.track.getMax());
+            worldData.addProperty("max-see-view-distance", world.sukiConfig().viewDistance.see.getMax());
+            worldData.addProperty("max-load-view-distance", world.sukiConfig().viewDistance.load.getMax());
+            // Suki end - per-player view distance
             worldData.addProperty("tick-view-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance()); // Paper - replace chunk loader system
             worldData.addProperty("keep-spawn-loaded", world.keepSpawnInMemory);
             worldData.addProperty("keep-spawn-loaded-range", world.paperConfig().spawn.keepSpawnLoadedRange * 16);
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 10a5762e3d5540e24839f82ea875b4daeb9f0603..72f167b52179c94b18554a249100aa576c4d5ceb 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -355,7 +355,7 @@ public class ChunkHolder {
         // Paper start - per player view distance
         // there can be potential desync with player's last mapped section and the view distance map, so use the
         // view distance map here.
-        com.destroystokyo.paper.util.misc.PlayerAreaMap viewDistanceMap = this.chunkMap.playerChunkManager.broadcastMap; // Paper - replace old player chunk manager
+        com.destroystokyo.paper.util.misc.PlayerAreaMap viewDistanceMap = this.chunkMap.playerChunkManager.broadcastMapForTracking; // Paper - replace old player chunk manager // Suki - per-player track and see view distance
         com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = viewDistanceMap.getObjectsInRange(this.pos);
         if (players == null) {
             return;
@@ -366,7 +366,7 @@ public class ChunkHolder {
             if (!(backingSet[i] instanceof ServerPlayer player)) {
                 continue;
             }
-            if (!this.chunkMap.playerChunkManager.isChunkSent(player, this.pos.x, this.pos.z, onlyOnWatchDistanceEdge)) {
+            if (!this.chunkMap.playerChunkManager.isChunkSent(player, this.pos.x, this.pos.z, onlyOnWatchDistanceEdge, true)) { // Suki - per-player track and see view distance
                 continue;
             }
             player.connection.send(packet);
@@ -416,7 +416,8 @@ public class ChunkHolder {
 
     public interface PlayerProvider {
 
-        List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge);
+        List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge, boolean concernsTracking); // Suki - per-player track and see view distance
+
     }
 
     private static final class ChunkSaveDebug {
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 3250f0f590ace90a5b9aa9dbac899f204955710c..dd2e82fbd47c5200dd0a25844071e8de0c094b3e 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -156,7 +156,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     private final Long2ByteMap chunkTypeCache;
     private final Long2LongMap chunkSaveCooldowns;
     private final Queue<Runnable> unloadQueue;
-    int viewDistance;
+    // Martijn start- per-player view distance
+    // This value is the intended world send view distance + 1
+    private int vanillaWorldViewDistancePlusOne;
+    // Suki end - per-player view distance
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobDistanceMap; // Paper
     public final ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting = new ReferenceOpenHashSet<>();
 
@@ -216,7 +219,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
             int trackRange = this.entityTrackerTrackRanges[i];
 
-            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, net.minecraft.server.ChunkSystem.getSendViewDistance(player)));
+            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, player.getTrackViewDistance())); // Paper - per player view distances // Suki - per-player track view distance
         }
         // Paper end - use distance map to optimise entity tracker
         this.playerGeneralAreaMap.add(player, chunkX, chunkZ, GENERAL_AREA_MAP_SQUARE_RADIUS); // Paper - optimise checkDespawn
@@ -242,11 +245,11 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper end - use distance map to optimise tracker
     }
 
-    void updateMaps(ServerPlayer player) {
+    void updateMaps(ServerPlayer player, boolean recalculateChunkLoadingMapsIfOnlyViewDistanceChanged) { // Suki - per-player view distance
         int chunkX = MCUtil.getChunkCoordinate(player.getX());
         int chunkZ = MCUtil.getChunkCoordinate(player.getZ());
         // Note: players need to be explicitly added to distance maps before they can be updated
-        this.playerChunkManager.updatePlayer(player); // Paper - replace chunk loader
+        this.playerChunkManager.updatePlayer(player, recalculateChunkLoadingMapsIfOnlyViewDistanceChanged); // Paper - replace chunk loader // Suki - per-player view distance
         this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, DistanceManager.MOB_SPAWN_RANGE); // Paper - optimise ChunkMap#anyPlayerCloseEnoughForSpawning
         // Paper start - per player mob spawning
         if (this.playerMobDistanceMap != null) {
@@ -258,7 +261,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
             int trackRange = this.entityTrackerTrackRanges[i];
 
-            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, net.minecraft.server.ChunkSystem.getSendViewDistance(player)));
+            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, player.getTrackViewDistance())); // Paper - per player view distances // Suki - per-player track view distance
         }
         // Paper end - use distance map to optimise entity tracker
         this.playerGeneralAreaMap.update(player, chunkX, chunkZ, GENERAL_AREA_MAP_SQUARE_RADIUS); // Paper - optimise checkDespawn
@@ -338,23 +341,21 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
     }
 
-    public Stream<ChunkHolder> getChunkHoldersSortedBySquaredPythagoreanDistanceToClosestPlayer(Stream<ChunkHolder> chunkHolders) {
-        return chunkHolders
-            .map(holder -> new ObjectObjectImmutablePair<>(holder, holder.getWorld().players
-                .stream()
-                .map(player -> player.getSquaredPythagoreanDistanceToChunk(holder.getPos().longKey))
-                .min(Long::compare)
-                .orElse(0L) // Happens in case there are no players in the world
-            ))
-            .sorted(Comparator.comparingLong(Pair::second))
-            .map(Pair::first);
-    }
-
-//    boolean unloadingPlayerChunk = false; // Paper - do not allow ticket level changes while unloading chunks
+//    public Stream<ChunkHolder> getChunkHoldersSortedBySquaredPythagoreanDistanceToClosestPlayer(Stream<ChunkHolder> chunkHolders) {
+//        return chunkHolders
+//            .map(holder -> new ObjectObjectImmutablePair<>(holder, holder.getWorld().players
+//                .stream()
+//                .map(player -> player.getSquaredPythagoreanDistanceToChunk(holder.getPos().longKey))
+//                .min(Long::compare)
+//                .orElse(0L) // Happens in case there are no players in the world
+//            ))
+//            .sorted(Comparator.comparingLong(Pair::second))
+//            .map(Pair::first);
+//    }
 
     // Suki end - sort chunks by distance
-    
-    public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int viewDistance, boolean dsync) {
+
+    public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int vanillaWorldViewDistance, boolean dsync) { // Suki - per-player view distance
         super(session.getDimensionPath(world.dimension()).resolve("region"), dataFixer, dsync);
         // Paper - rewrite chunk system
         this.tickingGenerated = new AtomicInteger();
@@ -397,7 +398,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.distanceManager = new ChunkMap.ChunkDistanceManager(executor, mainThreadExecutor);
         this.overworldDataStorage = persistentStateManagerFactory;
         this.poiManager = new PoiManager(path.resolve("poi"), dataFixer, dsync, world.registryAccess(), world);
-        this.setViewDistance(viewDistance);
+        this.setVanillaWorldViewDistance(vanillaWorldViewDistance); // Suki - per-player view distance
         // Paper start
         this.dataRegionManager = new io.papermc.paper.chunk.SingleThreadChunkRegionManager(this.level, 2, (1.0 / 3.0), 1, 6, "Data", DataRegionData::new, DataRegionSectionData::new);
         this.regionManagers.add(this.dataRegionManager);
@@ -611,13 +612,15 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
     }
 
+    // Suki start - per-player view distance
     // Paper start
-    public final int getEffectiveViewDistance() {
+    public final int getVanillaWorldViewDistance() {
         // TODO this needs to be checked on update
         // Mojang currently sets it to +1 of the configured view distance. So subtract one to get the one we really want.
-        return this.viewDistance - 1;
+        return this.vanillaWorldViewDistancePlusOne - 1;
     }
     // Paper end
+    // Suki end - per-player view distance
 
     private CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> getChunkRangeFuture(ChunkPos centerChunk, int margin, IntFunction<ChunkStatus> distanceToStatus) {
         throw new UnsupportedOperationException(); // Paper - rewrite chunk system
@@ -872,19 +875,25 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.playerChunkManager.setTickDistance(distance);
     }
     // Paper end - replace player loader system
-    public void setViewDistance(int watchDistance) {
-        int j = Mth.clamp(watchDistance + 1, (int) 3, (int) 33);
 
-        if (j != this.viewDistance) {
-            int k = this.viewDistance;
+    // Suki start - per-player view distance
+
+    public void setVanillaWorldViewDistance(int vanillaWorldViewDistance) {
+        int newVanillaWorldViewDistancePlusOne = Mth.clamp(vanillaWorldViewDistance + 1, (int) 3, (int) 33);
 
-            this.viewDistance = j;
-            this.playerChunkManager.setLoadDistance(this.viewDistance); // Paper - replace player loader system
+        if (newVanillaWorldViewDistancePlusOne != this.vanillaWorldViewDistancePlusOne) {
+            int k = this.vanillaWorldViewDistancePlusOne;
+
+            this.vanillaWorldViewDistancePlusOne = newVanillaWorldViewDistancePlusOne;
+            // No longer needed since PlayerChunkLoader.update() will pull the most current load view distance when it executes
+//            this.playerChunkManager.setLoadDistance(Mth.clamp(this.vanillaWorldViewDistancePlusOne, 2, 32)); // Paper - replace player loader system
         }
 
     }
 
-    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance) { // Paper - public // Paper - Anti-Xray - Bypass
+    // Suki end - per-player view distance
+
+    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance, boolean concernsTracking) { // Paper - Anti-Xray - Bypass // Paper - public // Suki - per-player track and see view distance
         if (player.level == this.level) {
             if (newWithinViewDistance && !oldWithinViewDistance) {
                 ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos.toLong());
@@ -893,7 +902,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                     LevelChunk chunk = playerchunk.getSendingChunk(); // Paper - replace chunk loader system
 
                     if (chunk != null) {
-                        this.playerLoadedChunk(player, packet, chunk);
+                        this.playerLoadedChunk(player, packet, chunk, concernsTracking); // Suki - per-player track and see view distance
                     }
 
                     DebugPackets.sendPoiPacketsForChunk(this.level, pos);
@@ -901,7 +910,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
 
             if (!newWithinViewDistance && oldWithinViewDistance) {
-                player.untrackChunk(pos);
+                player.untrackChunk(pos, concernsTracking); // Suki - per-player track and see view distance
             }
 
         }
@@ -1163,6 +1172,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public void move(ServerPlayer player) {
         // Paper - delay this logic for the entity tracker tick, no need to duplicate it
 
+        this.level.timings.chunkMapPlayerMove.startTiming(); // Suki - per-player view distance
+
         int i = SectionPos.blockToSectionCoord(player.getBlockX());
         int j = SectionPos.blockToSectionCoord(player.getBlockZ());
         SectionPos sectionposition = player.getLastSectionPos();
@@ -1203,17 +1214,22 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         // Paper - replaced by PlayerChunkLoader
 
-        this.updateMaps(player); // Paper - distance maps
-        this.playerChunkManager.updatePlayer(player); // Paper - respond to movement immediately
+        // Suki start - per-player view distance
+        this.updateMaps(player, false); // Paper - distance maps
+        this.playerChunkManager.updatePlayer(player, false); // Paper - respond to movement immediately
+        // Suki end - per-player view distance
+
+        this.level.timings.chunkMapPlayerMove.stopTiming(); // Suki - per-player view distance
 
     }
 
     @Override
-    public List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge) {
+    public List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge, boolean concernsTracking) { // Suki - per-player track and see view distance
         // Paper start - per player view distance
         // there can be potential desync with player's last mapped section and the view distance map, so use the
         // view distance map here.
-        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = this.playerChunkManager.broadcastMap.getObjectsInRange(chunkPos);
+
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = this.playerChunkManager.getBroadcastMap(concernsTracking).getObjectsInRange(chunkPos); // Suki - per-player track and see view distance
         if (players == null) {
             return java.util.Collections.emptyList();
         }
@@ -1330,6 +1346,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end - optimised tracker
 
     protected void tick() {
+
+        // Suki start - temporary debug message containing the number of loaded chunks
+        if (this.level.sukiConfig().viewDistance.load.printLoadedChunksInterval > 0 && Math.random() < 1.0 / this.level.sukiConfig().viewDistance.load.printLoadedChunksInterval) {
+            org.bukkit.Bukkit.getLogger().info("Number of loaded chunks in " + this.level.getWorld().getName() + ": " + this.level.getWorld().getLoadedChunks().length);
+        }
+        // Suki end - temporary debug message containing the number of loaded chunks
+
         // Paper start - optimized tracker
         if (true) {
             this.processTrackQueue();
@@ -1438,7 +1461,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end - Fix MC-162253
 
     // Paper start - Anti-Xray - Bypass
-    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk) {
+    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk, boolean concernsTracking) { // Suki - per-player track and see view distance
         if (cachedDataPackets.getValue() == null) {
             cachedDataPackets.setValue(new java.util.HashMap<>());
         }
@@ -1446,7 +1469,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
         player.trackChunk(chunk.getPos(), (Packet) cachedDataPackets.getValue().computeIfAbsent(shouldModify, (s) -> {
             // Paper start - Fix MC-162253
-            final int viewDistance = getEffectiveViewDistance();
+            final int viewDistance = getVanillaWorldViewDistance(); // Suki - per-player view distance
             final int playerChunkX = player.getBlockX() >> 4;
             final int playerChunkZ = player.getBlockZ() >> 4;
 
@@ -1485,11 +1508,69 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
             // Paper end - Fix MC-162253
             return new ClientboundLevelChunkWithLightPacket(chunk, this.lightEngine, (BitSet) null, (BitSet) null, true, (Boolean) s);
-        }));
+        }), concernsTracking);
         // Paper end
         DebugPackets.sendPoiPacketsForChunk(this.level, chunk.getPos());
+
+        // Suki start - per-player track and see view distance
+
         // Paper - no longer needed - this was used to account for clients bugging out since they needed a chunk to store entities, but they no longer need a chunk
 
+//        if (concernsTracking) {
+//
+//            List<Entity> list = Lists.newArrayList();
+//            List<Entity> list1 = Lists.newArrayList();
+//            // Paper start - optimise entity tracker
+//            // use the chunk entity list, not the whole trackedEntities map...
+//            Entity[] entities = chunk.entities.getRawData();
+//            for (int i = 0, size = chunk.entities.size(); i < size; ++i) {
+//                Entity entity = entities[i];
+//                if (entity == player) {
+//                    continue;
+//                }
+//                ChunkMap.TrackedEntity tracker = this.entityMap.get(entity.getId());
+//                if (tracker != null) { // dumb plugins... move on...
+//                    tracker.updatePlayer(player);
+//                }
+//
+//                // keep the vanilla logic here - this is REQUIRED or else passengers and their vehicles disappear!
+//                // (and god knows what the leash thing is)
+//
+//                if (entity instanceof Mob && ((Mob) entity).getLeashHolder() != null) {
+//                    list.add(entity);
+//                }
+//
+//                if (!entity.getPassengers().isEmpty()) {
+//                    list1.add(entity);
+//                }
+//            }
+//            // Paper end - optimise entity tracker
+//
+//            Iterator iterator;
+//            Entity entity1;
+//
+//            if (!list.isEmpty()) {
+//                iterator = list.iterator();
+//
+//                while (iterator.hasNext()) {
+//                    entity1 = (Entity) iterator.next();
+//                    player.connection.send(new ClientboundSetEntityLinkPacket(entity1, ((Mob) entity1).getLeashHolder()));
+//                }
+//            }
+//
+//            if (!list1.isEmpty()) {
+//                iterator = list1.iterator();
+//
+//                while (iterator.hasNext()) {
+//                    entity1 = (Entity) iterator.next();
+//                    player.connection.send(new ClientboundSetPassengersPacket(entity1));
+//                }
+//            }
+//
+//        }
+
+        // Suki end - per-player track and see view distance
+
     }
 
     public PoiManager getPoiManager() {
@@ -1633,7 +1714,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 double vec3d_dx = player.getX() - this.entity.getX();
                 double vec3d_dz = player.getZ() - this.entity.getZ();
                 // Paper end - remove allocation of Vec3D here
-                double d0 = (double) Math.min(this.getEffectiveRange(), io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player) * 16); // Paper - per player view distance
+                double d0 = (double) Math.min(this.getEffectiveRange(), player.getTrackViewDistance() * 16); // Paper - per player view distance // Suki - per-player track view distance
                 double d1 = vec3d_dx * vec3d_dx + vec3d_dz * vec3d_dz; // Paper
                 double d2 = d0 * d0;
                 boolean flag = d1 <= d2 && this.entity.broadcastToPlayer(player);
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index 52cba8f68d274cce106304aef1249a95474d3238..12f07471c03a12995086085a0162472c33e0ba64 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -183,9 +183,12 @@ public abstract class DistanceManager {
         return this.getChunkHolderManager().getTicketDebugString(pos); // Paper - rewrite chunk system
     }
 
-    protected void updatePlayerTickets(int viewDistance) {
-        this.chunkMap.playerChunkManager.setTargetNoTickViewDistance(viewDistance); // Paper - route to player chunk manager
-    }
+    // Suki start - per-player load view distance
+    // No longer needed since PlayerChunkLoader.update() will pull the most current load view distance when it executes
+//    protected void updatePlayerTickets(int viewDistance) {
+//        this.chunkMap.playerChunkManager.setTargetNoTickViewDistance(viewDistance); // Paper - route to player chunk manager
+//    }
+    // Suki end - per-player load view distance
 
     // Paper start
     public int getSimulationDistance() {
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index 16ee24bef4eb2184d821565665f3c1ddf0f3bb39..2c3548d36fd21514c1ced0376ddcd8f172c2f179 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -678,7 +678,7 @@ public class ServerChunkCache extends ChunkSource {
                     continue;
                 }
 
-                int viewDistance = this.chunkMap.getEffectiveViewDistance();
+                int viewDistance = this.chunkMap.getVanillaWorldViewDistance(); // Suki - per-player view distance
 
                 // copied and modified from isOutisdeRange
                 int chunkRange = level.spigotConfig.mobSpawnRange;
@@ -956,9 +956,11 @@ public class ServerChunkCache extends ChunkSource {
         this.chunkMap.broadcast(entity, packet);
     }
 
-    public void setViewDistance(int watchDistance) {
-        this.chunkMap.setViewDistance(watchDistance);
+    // Suki start - per-player view distance
+    public void setVanillaWorldViewDistance(int vanillaWorldViewDistance) {
+        this.chunkMap.setVanillaWorldViewDistance(vanillaWorldViewDistance);
     }
+    // Suki end - per-player view distance
 
     public void setSimulationDistance(int simulationDistance) {
         this.distanceManager.updateSimulationDistance(simulationDistance);
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 4c35d884c7b959d9ea0aba927d962e16ad573185..ff039f448a2da91184fec8b7808d3cfa7ec603fa 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -1,6 +1,6 @@
 package net.minecraft.server.level;
 
-import com.destroystokyo.paper.PaperConfig;
+import co.aikar.timings.Timing;
 import com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent;
 import com.google.common.collect.Lists;
 import com.mojang.authlib.GameProfile;
@@ -8,8 +8,6 @@ import com.mojang.datafixers.util.Either;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
 
-import java.util.ArrayDeque;
-import java.util.BitSet;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.Iterator;
@@ -18,16 +16,12 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalInt;
 import java.util.UUID;
-import java.util.Random;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
 
+import io.papermc.paper.chunk.PlayerChunkLoader;
 import it.unimi.dsi.fastutil.Pair;
 import it.unimi.dsi.fastutil.ints.IntIntPair;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import it.unimi.dsi.fastutil.longs.LongSet;
-import it.unimi.dsi.fastutil.objects.Object2ObjectMap;
-import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectObjectImmutablePair;
 import net.minecraft.BlockUtil;
 import net.minecraft.ChatFormatting;
@@ -69,8 +63,6 @@ import net.minecraft.network.protocol.game.ClientboundEntityEventPacket;
 import net.minecraft.network.protocol.game.ClientboundForgetLevelChunkPacket;
 import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
 import net.minecraft.network.protocol.game.ClientboundHorseScreenOpenPacket;
-import net.minecraft.network.protocol.game.ClientboundKeepAlivePacket;
-import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
 import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.protocol.game.ClientboundMerchantOffersPacket;
 import net.minecraft.network.protocol.game.ClientboundOpenBookPacket;
@@ -87,14 +79,11 @@ import net.minecraft.network.protocol.game.ClientboundResourcePackPacket;
 import net.minecraft.network.protocol.game.ClientboundRespawnPacket;
 import net.minecraft.network.protocol.game.ClientboundServerDataPacket;
 import net.minecraft.network.protocol.game.ClientboundSetCameraPacket;
-import net.minecraft.network.protocol.game.ClientboundSetEntityLinkPacket;
 import net.minecraft.network.protocol.game.ClientboundSetExperiencePacket;
 import net.minecraft.network.protocol.game.ClientboundSetHealthPacket;
-import net.minecraft.network.protocol.game.ClientboundSetPassengersPacket;
 import net.minecraft.network.protocol.game.ClientboundSoundPacket;
 import net.minecraft.network.protocol.game.ClientboundSystemChatPacket;
 import net.minecraft.network.protocol.game.ClientboundUpdateMobEffectPacket;
-import net.minecraft.network.protocol.game.DebugPackets;
 import net.minecraft.network.protocol.game.ServerboundClientInformationPacket;
 import net.minecraft.network.protocol.status.ServerStatus;
 import net.minecraft.resources.ResourceKey;
@@ -160,7 +149,6 @@ import net.minecraft.world.level.block.entity.CommandBlockEntity;
 import net.minecraft.world.level.block.entity.SignBlockEntity;
 import net.minecraft.world.level.block.state.BlockState;
 import net.minecraft.world.level.border.WorldBorder;
-import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.dimension.LevelStem;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.level.portal.PortalInfo;
@@ -196,11 +184,293 @@ import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.inventory.MainHand;
 import org.sucraft.suki.configuration.SukiGlobalConfiguration;
+import org.jetbrains.annotations.NotNull;
 // CraftBukkit end
 
 public class ServerPlayer extends Player {
 
     private static final Logger LOGGER = LogUtils.getLogger();
+
+    // Suki start - per-player view distance
+
+    private static int[] maxViewDistanceDueToTotalViewedChunks = {32, 32};
+
+    /**
+     * Does not change any state
+     * Is called only from ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type)
+     */
+    private static int computeMaxViewDistanceDueToTotalViewedChunks(int type) {
+        int maxTotalChunks = ((type == 0) ? SukiGlobalConfiguration.get().viewDistance.track : SukiGlobalConfiguration.get().viewDistance.see).getMaxTotalChunks();
+        if (maxTotalChunks == -1) return -1;
+        int candidateViewDistance = maxViewDistanceDueToTotalViewedChunks[type];
+        int[] playerViewDistances = new int[MinecraftServer.getServer().getPlayerCount()];
+        int playerI = 0;
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().players) {
+            playerViewDistances[playerI] = player.getViewDistance(type);
+            playerI++;
+        }
+        for (boolean increase : new boolean[] {false, true}) {
+            int chunks = 0;
+            for (int playerViewDistance : playerViewDistances) {
+                // We assume the worst: that if the player's view distance is equal to the current limit, that it will definitely grow to the new limit
+                int playerViewDistanceUnderCandidateAssumption = playerViewDistance >= ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] ? candidateViewDistance : Math.min(candidateViewDistance, playerViewDistance);
+                int playerViewDimensionUnderCandidateAssumption = playerViewDistanceUnderCandidateAssumption * 2 + 1;
+                chunks += playerViewDimensionUnderCandidateAssumption * playerViewDimensionUnderCandidateAssumption;
+            }
+            if (candidateViewDistance > 2 && (chunks > maxTotalChunks || candidateViewDistance > 32)) {
+                candidateViewDistance--;
+                if (increase) {
+                    continue;
+                }
+            } else {
+                candidateViewDistance++;
+                if (!increase) {
+                    continue;
+                }
+            }
+        }
+        return candidateViewDistance;
+    }
+
+    /**
+     * Is called only from ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type)
+     */
+    private static void processMaxViewDistanceDueToTotalViewedChunksChange(int oldMaxViewDistanceDueToTotalViewedChunks, int type) {
+        if (oldMaxViewDistanceDueToTotalViewedChunks == ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type]) return;
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().players) {
+            player.viewDistanceMayHaveChanged(type);
+        }
+    }
+
+    public static void maxTrackViewDistanceDueToTotalTrackedChunksMayHaveChanged() {
+        ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(0);
+    }
+
+    public static void maxSeeViewDistanceDueToTotalSeenChunksMayHaveChanged() {
+        ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(1);
+    }
+
+    /**
+     * Is called only from ServerPlayer.processViewDistanceChange(type)
+     */
+    private static void maxViewDistanceDueToTotalViewedChunksMayHaveChanged(int type) {
+        int oldMaxViewDistanceDueToTotalViewedChunks = ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type];
+        ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] = ServerPlayer.computeMaxViewDistanceDueToTotalViewedChunks(type);
+        ServerPlayer.processMaxViewDistanceDueToTotalViewedChunksChange(oldMaxViewDistanceDueToTotalViewedChunks, type);
+    }
+
+    private final int getWorldSeeViewDistance() { return this.getLevel().getChunkSource().chunkMap.getVanillaWorldViewDistance() - 1; } // Paper - placeholder
+
+    private final int getWorldTrackViewDistance() {
+        return this.getWorldSeeViewDistance();
+    }
+
+    private final int getWorldLoadViewDistance() {
+        return this.getWorldSeeViewDistance() + 1;
+    }
+
+    private final int getWorldViewDistance(int type) {
+        switch (type) {
+            case 0: return this.getWorldTrackViewDistance();
+            case 1: return this.getWorldSeeViewDistance();
+            case 2: return this.getWorldLoadViewDistance();
+        }
+        throw new IllegalArgumentException();
+    }
+
+    private @Nullable Integer @NotNull [] viewDistances = {null, null, null};
+
+    public final int getTrackViewDistance() {
+        return this.getViewDistance(0);
+    }
+
+    public final int getSeeViewDistance() {
+        return this.getViewDistance(1);
+    }
+
+    public final int getLoadViewDistance() {
+        return this.getViewDistance(2);
+    }
+
+    public final int getTickingViewDistance() {
+        int loadViewDistanceMinusOne = this.getLoadViewDistance() - 1;
+        ServerLevel level = this.getLevel();
+        if (level != null) {
+            PlayerChunkLoader playerChunkLoader = level.getChunkSource().chunkMap.playerChunkManager;
+            PlayerChunkLoader.PlayerLoaderData data = playerChunkLoader.getData(this);
+            if (data != null && data.tickViewDistance != -1) {
+                return Math.min(loadViewDistanceMinusOne, data.tickViewDistance);
+            }
+            return Math.min(loadViewDistanceMinusOne, playerChunkLoader.getTickDistance());
+        }
+        return loadViewDistanceMinusOne;
+    }
+
+    private final int getViewDistance(int type) {
+        if (this.viewDistances[type] == null) {
+            this.viewDistanceMayHaveChanged(type);
+        }
+        return this.viewDistances[type];
+    }
+
+    public final void trackViewDistanceMayHaveChanged() {
+        this.viewDistanceMayHaveChanged(0);
+    }
+
+    public final void seeViewDistanceMayHaveChanged() {
+        this.viewDistanceMayHaveChanged(1);
+    }
+
+    public final void loadViewDistanceMayHaveChanged() {
+        this.viewDistanceMayHaveChanged(2);
+    }
+
+    /**
+     * Does not change any state
+     * Is called only from ServerPlayer.viewDistanceMayHaveChanged(type)
+     */
+    private final int computeViewDistance(int type) {
+        switch (type) {
+            case 0: {
+                this.level.timings.computeTrackViewDistance.startTiming();
+
+                // Limit by world view distance
+                int trackViewDistance = this.getWorldTrackViewDistance();
+                // Limit by see view distance
+                trackViewDistance = Math.min(trackViewDistance, this.getSeeViewDistance());
+                if (this.getLevel().sukiConfig().viewDistance.track.getPerPlayer()) {
+                    // Limit by world max track view distance
+                    int levelMaxTrackViewDistance = this.getLevel().sukiConfig().viewDistance.track.getMax();
+                    if (levelMaxTrackViewDistance != -1) {
+                        trackViewDistance = Math.min(trackViewDistance, levelMaxTrackViewDistance);
+                    }
+                    // Limit by client view distance
+                    if (this.getLevel().sukiConfig().viewDistance.track.getLimitByClientViewDistance()) {
+                        if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                            trackViewDistance = Math.min(trackViewDistance, this.clientViewDistance + 1);
+                        }
+                    }
+                }
+                // Limit by max total tracked chunks
+                if (ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] != -1) {
+                    trackViewDistance = Math.min(trackViewDistance, ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type]);
+                }
+                // Clamp to possible values
+                trackViewDistance = Mth.clamp(trackViewDistance, 2, 32);
+
+                this.level.timings.computeTrackViewDistance.stopTiming();
+
+                return trackViewDistance;
+            }
+            case 1: {
+                this.level.timings.computeSeeViewDistance.startTiming();
+
+                // Limit by world view distance
+                int seeViewDistance = this.getWorldSeeViewDistance();
+                if (this.getLevel().sukiConfig().viewDistance.see.getPerPlayer()) {
+                    // Limit by world max see view distance
+                    int levelMaxSeeViewDistance = this.getLevel().sukiConfig().viewDistance.see.getMax();
+                    if (levelMaxSeeViewDistance != -1) {
+                        seeViewDistance = Math.min(seeViewDistance, levelMaxSeeViewDistance);
+                    }
+                    // Limit by client view distance
+                    if (this.getLevel().sukiConfig().viewDistance.see.getLimitByClientViewDistance()) {
+                        if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                            seeViewDistance = Math.min(seeViewDistance, this.clientViewDistance + 1);
+                        }
+                    }
+                }
+                // Limit by max total seen chunks
+                if (ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] != -1) {
+                    seeViewDistance = Math.min(seeViewDistance, ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type]);
+                }
+                // Clamp to possible values
+                seeViewDistance = Mth.clamp(seeViewDistance, 2, 32);
+
+                this.level.timings.computeSeeViewDistance.stopTiming();
+
+                return seeViewDistance;
+            }
+            case 2: {
+                this.level.timings.computeLoadViewDistance.startTiming();
+
+                // Limit by world view distance
+                int loadViewDistance = this.getWorldLoadViewDistance();
+                if (this.getLevel().sukiConfig().viewDistance.load.getPerPlayer()) {
+                    // Limit by world max load view distance
+                    int levelMaxLoadViewDistance = this.getLevel().sukiConfig().viewDistance.load.getMax();
+                    if (levelMaxLoadViewDistance != -1) {
+                        loadViewDistance = Math.min(loadViewDistance, levelMaxLoadViewDistance);
+                    }
+                    // Limit by see view distance
+                    if (this.getLevel().sukiConfig().viewDistance.load.getLimitBySeeViewDistance()) {
+                        loadViewDistance = Math.min(loadViewDistance, this.getSeeViewDistance() + 1);
+                    }
+                    // Limit by client view distance
+                    if (this.getLevel().sukiConfig().viewDistance.load.getLimitByClientViewDistance()) {
+                        if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                            loadViewDistance = Math.min(loadViewDistance, this.clientViewDistance + 2);
+                        }
+                    }
+                }
+                // Clamp to possible values
+                loadViewDistance = Mth.clamp(loadViewDistance, 3, 33);
+
+                this.level.timings.computeLoadViewDistance.stopTiming();
+
+                return loadViewDistance;
+            }
+        }
+        throw new IllegalArgumentException();
+    }
+
+    /**
+     * Is called only from ServerPlayer.viewDistanceMayHaveChanged(type)
+     */
+    private final void processViewDistanceChange(@Nullable Integer oldViewDistance, int type) {
+
+        int newViewDistance = this.viewDistances[type];
+        if (oldViewDistance != null && oldViewDistance == newViewDistance) return;
+
+        switch (type) {
+            case 0: {
+                this.level.timings.processTrackViewDistanceChange.startTiming();
+                // Update track view distance of other players
+                maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type);
+                this.level.timings.processTrackViewDistanceChange.stopTiming();
+                break;
+            }
+            case 1: {
+                this.level.timings.processSeeViewDistanceChange.startTiming();
+                // Update track view distance
+                this.trackViewDistanceMayHaveChanged();
+                // Update load view distance
+                this.loadViewDistanceMayHaveChanged();
+                // Update see view distance of other players
+                maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type);
+                this.level.timings.processSeeViewDistanceChange.stopTiming();
+                break;
+            }
+        }
+
+    }
+
+    private final void viewDistanceMayHaveChanged(int type) {
+        Timing timing = switch (type) {
+            case 0 -> this.level.timings.trackViewDistanceMayHaveChanged;
+            case 1 -> this.level.timings.seeViewDistanceMayHaveChanged;
+            case 2 -> this.level.timings.loadViewDistanceMayHaveChanged;
+            default -> null;
+        };
+        timing.startTiming();
+        Integer oldViewDistance = this.viewDistances[type];
+        this.viewDistances[type] = this.computeViewDistance(type);
+        this.processViewDistanceChange(oldViewDistance, type);
+        timing.stopTiming();
+    }
+
+    // Suki end - per-player view distance
+
     public long lastSave = MinecraftServer.currentTick; // Paper
     private static final int NEUTRAL_MOB_DEATH_NOTIFICATION_RADII_XZ = 32;
     private static final int NEUTRAL_MOB_DEATH_NOTIFICATION_RADII_Y = 10;
@@ -1988,6 +2258,11 @@ public class ServerPlayer extends Player {
         this.connection.connection.channel.attr(PaperAdventure.LOCALE_ATTRIBUTE).set(this.adventure$locale);
         // Paper end
         this.clientViewDistance = packet.getAcceptableViewDistance(); // Suki - allow invalid client view distance
+        // Suki start - per-player view distance
+        this.trackViewDistanceMayHaveChanged();
+        this.seeViewDistanceMayHaveChanged();
+        this.loadViewDistanceMayHaveChanged();
+        // Suki end - per-player view distance
         // CraftBukkit end
         this.chatVisibility = packet.chatVisibility();
         this.canChatColor = packet.chatColors();
@@ -2248,27 +2523,37 @@ public class ServerPlayer extends Player {
         return true; // Paper
     }
 
-    public void trackChunk(ChunkPos chunkPos, Packet<?> chunkDataPacket) {
+    // Suki start - per-player track and see view distance
+
+    public void trackChunk(ChunkPos chunkPos, Packet<?> chunkDataPacket, boolean concernsTracking) {
         this.connection.send(chunkDataPacket);
-        // Paper start
-        if(io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0){
-            new io.papermc.paper.event.packet.PlayerChunkLoadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+        if (concernsTracking) {
+            // Paper start
+            if (io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                new io.papermc.paper.event.packet.PlayerChunkLoadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+            }
+            // Paper end
         }
-        // Paper end
     }
 
-    public void untrackChunk(ChunkPos chunkPos) {
+    public void untrackChunk(ChunkPos chunkPos, boolean concernsTracking) {
         if (this.isAlive()) {
-            this.connection.send(new ClientboundForgetLevelChunkPacket(chunkPos.x, chunkPos.z));
-            // Paper start
-            if(io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0){
-                new io.papermc.paper.event.packet.PlayerChunkUnloadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+            if (!concernsTracking) {
+                this.connection.send(new ClientboundForgetLevelChunkPacket(chunkPos.x, chunkPos.z));
+            }
+            if (concernsTracking) {
+                // Paper start
+                if (io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                    new io.papermc.paper.event.packet.PlayerChunkUnloadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+                }
+                // Paper end
             }
-            // Paper end
         }
 
     }
 
+    // Suki end - per-player track and see view distance
+
     public SectionPos getLastSectionPos() {
         return this.lastSectionPos;
     }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 7161da05bd145b934aee90ec906ccea1edb50935..037ee11af81ca65852de7fe403a88339babb51f7 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -24,7 +24,6 @@ import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
 import java.util.function.Function;
-import java.util.function.Predicate;
 import javax.annotation.Nullable;
 import net.minecraft.ChatFormatting;
 import net.minecraft.FileUtil;
@@ -99,6 +98,7 @@ import net.minecraft.world.scores.Team;
 import org.slf4j.Logger;
 
 // CraftBukkit start
+import com.google.common.base.Predicate;
 import java.util.stream.Collectors;
 import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.ServerLevel;
@@ -113,7 +113,6 @@ import org.bukkit.Location;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.entity.Player;
 import org.bukkit.event.player.PlayerChangedWorldEvent;
 import org.bukkit.event.player.PlayerJoinEvent;
@@ -277,7 +276,8 @@ public abstract class PlayerList {
         boolean flag1 = gamerules.getBoolean(GameRules.RULE_REDUCEDDEBUGINFO);
 
         // Spigot - view distance
-        playerconnection.send(new ClientboundLoginPacket(player.getId(), worlddata.isHardcore(), player.gameMode.getGameModeForPlayer(), player.gameMode.getPreviousGameModeForPlayer(), this.server.levelKeys(), this.registryHolder, worldserver1.dimensionTypeId(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), this.getMaxPlayers(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance(), flag1, !flag, worldserver1.isDebug(), worldserver1.isFlat(), player.getLastDeathLocation())); // Paper - replace old player chunk management
+        playerconnection.send(new ClientboundLoginPacket(player.getId(), worlddata.isHardcore(), player.gameMode.getGameModeForPlayer(), player.gameMode.getPreviousGameModeForPlayer(), this.server.levelKeys(), this.registryHolder, worldserver1.dimensionTypeId(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), this.getMaxPlayers(), player.getSeeViewDistance(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance(), flag1, !flag, worldserver1.isDebug(), worldserver1.isFlat(), player.getLastDeathLocation())); // Paper - replace old player chunk management // Suki - per-player view distance
+
         player.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.send(new ClientboundCustomPayloadPacket(ClientboundCustomPayloadPacket.BRAND, (new FriendlyByteBuf(Unpooled.buffer())).writeUtf(this.getServer().getServerModName())));
         playerconnection.send(new ClientboundChangeDifficultyPacket(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
@@ -972,7 +972,7 @@ public abstract class PlayerList {
         // CraftBukkit start
         LevelData worlddata = worldserver1.getLevelData();
         if (!entityplayer.smoothWorldTeleport) entityplayer1.connection.send(new ClientboundRespawnPacket(worldserver1.dimensionTypeId(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), entityplayer1.gameMode.getGameModeForPlayer(), entityplayer1.gameMode.getPreviousGameModeForPlayer(), worldserver1.isDebug(), worldserver1.isFlat(), flag, entityplayer1.getLastDeathLocation())); // Slice
-        entityplayer1.connection.send(new ClientboundSetChunkCacheRadiusPacket(worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance())); // Spigot // Paper - replace old player chunk management
+        entityplayer1.connection.send(new ClientboundSetChunkCacheRadiusPacket(entityplayer1.getSeeViewDistance())); // Spigot // Paper - replace old player chunk management // Suki - per-player see view distance
         entityplayer1.connection.send(new ClientboundSetSimulationDistancePacket(worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance())); // Spigot // Paper - replace old player chunk management
         entityplayer1.spawnIn(worldserver1);
         entityplayer1.unsetRemoved();
@@ -1550,7 +1550,7 @@ public abstract class PlayerList {
             ServerLevel worldserver = (ServerLevel) iterator.next();
 
             if (worldserver != null) {
-                worldserver.getChunkSource().setViewDistance(viewDistance);
+                worldserver.getChunkSource().setVanillaWorldViewDistance(viewDistance); // Suki - per-player view distance
             }
         }
 
diff --git a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
index ac3d4d90407288526a8c787e365ff41234a58543..59bce4579700b3cbb742e36a57d2b63a962dc629 100644
--- a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
+++ b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
@@ -5,6 +5,8 @@ import com.mojang.logging.LogUtils;
 import java.util.Iterator;
 import java.util.List;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.configuration.GlobalConfiguration;
 import net.minecraft.core.BlockPos;
 import net.minecraft.core.particles.ParticleTypes;
 import net.minecraft.nbt.CompoundTag;
@@ -675,8 +677,9 @@ public class EnderDragon extends Mob implements Enemy {
             if (this.dragonDeathTime == 1 && !this.isSilent()) {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1028, this.getChunkCoordinates(), 0);
-                int viewDistance = ((ServerLevel) this.level).getCraftServer().getViewDistance() * 16;
+//                int viewDistance = ((ServerLevel) this.level).getCraftServer().getViewDistance() * 16; // Suki - per-player track and see view distance
                 for (net.minecraft.server.level.ServerPlayer player : (List<net.minecraft.server.level.ServerPlayer>) ((ServerLevel)level).players()) {
+                    final int viewDistance = (level.sukiConfig().viewDistance.ifCanSeeButNotTracking.sendEnderDragonSpawnSound ? player.getSeeViewDistance() : player.getTrackViewDistance()) * 16; // Paper - route to player chunk loader // Suki - per-player track and see view distance
                     double deltaX = this.getX() - player.getX();
                     double deltaZ = this.getZ() - player.getZ();
                     double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
index 50851944dcd1d8177b271c32f2c603982c897aec..8ace269a96c3c33c23973c0390b34367ad815289 100644
--- a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
+++ b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
@@ -5,6 +5,8 @@ import java.util.EnumSet;
 import java.util.List;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.configuration.GlobalConfiguration;
 import net.minecraft.world.BossEvent;
 import net.minecraft.world.Difficulty;
 import net.minecraft.world.damagesource.DamageSource;
@@ -47,9 +49,7 @@ import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.network.syncher.EntityDataSerializers;
 import net.minecraft.network.syncher.SynchedEntityData;
-import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerBossEvent;
-import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
@@ -276,8 +276,9 @@ public class WitherBoss extends Monster implements PowerableMob, RangedAttackMob
                 if (!this.isSilent()) {
                     // CraftBukkit start - Use relative location for far away sounds
                     // this.world.globalLevelEvent(1023, new BlockPosition(this), 0);
-                    int viewDistance = ((ServerLevel) this.level).getCraftServer().getViewDistance() * 16;
+//                    int viewDistance = ((ServerLevel) this.level).getCraftServer().getViewDistance() * 16; // Suki - per-player track and see view distance
                     for (ServerPlayer player : (List<ServerPlayer>)this.level.players()) { // Paper
+                        final int viewDistance = (this.level.sukiConfig().viewDistance.ifCanSeeButNotTracking.sendWitherSpawnSound ? player.getSeeViewDistance() : player.getTrackViewDistance()) * 16; // Paper - route to player chunk loader // Suki - per-player track and see view distance
                         double deltaX = this.getX() - player.getX();
                         double deltaZ = this.getZ() - player.getZ();
                         double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/item/EnderEyeItem.java b/src/main/java/net/minecraft/world/item/EnderEyeItem.java
index 0b3e9e4ed162a6d9e1f3f55b9522b75c94d13254..d66cba8dd5af7a98569f68a85cc9522aba45030e 100644
--- a/src/main/java/net/minecraft/world/item/EnderEyeItem.java
+++ b/src/main/java/net/minecraft/world/item/EnderEyeItem.java
@@ -25,6 +25,7 @@ import net.minecraft.world.level.block.state.pattern.BlockPattern;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.HitResult;
+import org.sucraft.suki.configuration.SukiGlobalConfiguration;
 
 public class EnderEyeItem extends Item {
 
@@ -62,9 +63,10 @@ public class EnderEyeItem extends Item {
 
                     // CraftBukkit start - Use relative location for far away sounds
                     // world.b(1038, blockposition1.c(1, 0, 1), 0);
-                    int viewDistance = world.getCraftServer().getViewDistance() * 16;
+//                    int viewDistance = world.getCraftServer().getViewDistance() * 16; // Suki - per-player track and see view distance
                     BlockPos soundPos = blockposition1.offset(1, 0, 1);
                     for (ServerPlayer player : world.getServer().getPlayerList().players) {
+                        final int viewDistance = (world.sukiConfig().viewDistance.ifCanSeeButNotTracking.sendEndPortalFillSound ? player.getSeeViewDistance() : player.getTrackViewDistance()) * 16; // Paper - apply view distance patch // Suki - per-player track and see view distance
                         double deltaX = soundPos.getX() - player.getX();
                         double deltaZ = soundPos.getZ() - player.getZ();
                         double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index e8a7c938a065c9c68669eee84c77702a303266c9..7a405568f8f0c0b998a8d0f92e0eaf08821b1a4f 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -738,7 +738,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 this.sendBlockUpdated(blockposition, iblockdata1, iblockdata, i);
                 // Paper start - per player view distance - allow block updates for non-ticking chunks in player view distance
                 // if copied from above
-            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((ServerLevel)this).getChunkSource().chunkMap.playerChunkManager.broadcastMap.getObjectsInRange(MCUtil.getCoordinateKey(blockposition)) != null)) { // Paper - replace old player chunk management
+            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((ServerLevel)this).getChunkSource().chunkMap.playerChunkManager.getBroadcastMap(true).getObjectsInRange(MCUtil.getCoordinateKey(blockposition)) != null)) { // Paper - replace old player chunk management // Suki - per-player track and see view distance
                 ((ServerLevel)this).getChunkSource().blockChanged(blockposition);
                 // Paper end - per player view distance
             }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 6ba7d8c32cdd51c2c291ccafe0a9d145c88155f5..2ff642be7fe395f909e08812b55e120601059137 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -228,7 +228,7 @@ public class LevelChunk extends ChunkAccess {
         // this code handles the chunk sending
         if (!areNeighboursLoaded(bitsetBefore, 1) && areNeighboursLoaded(bitsetAfter, 1)) {
             // Paper start - replace old player chunk loading system
-            if (chunkMap.playerChunkManager.isChunkNearPlayers(this.chunkPos.x, this.chunkPos.z)) {
+            if (chunkMap.playerChunkManager.isChunkNearPlayers(this.chunkPos.x, this.chunkPos.z, false)) { // Suki - per-player track and see view distance
                 // the post processing is expensive, so we don't want to run it unless we're actually near
                 // a player.
                 chunkProviderServer.mainThreadProcessor.execute(() -> {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 72ed25022d5ea1074304be3c72b23882b8f0f88a..02cb6a9a5f2c59e5df22a2ded01e819f733bab65 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -5,6 +5,7 @@ import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.mojang.datafixers.util.Pair;
+import io.papermc.paper.configuration.GlobalConfiguration;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
@@ -21,7 +22,6 @@ import java.util.Objects;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
-import java.util.concurrent.ExecutionException;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import net.minecraft.core.BlockPos;
@@ -43,7 +43,6 @@ import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.level.Ticket;
 import net.minecraft.server.level.TicketType;
 import net.minecraft.sounds.SoundSource;
-import net.minecraft.tags.TagKey;
 import net.minecraft.util.SortedArraySet;
 import net.minecraft.util.Unit;
 import net.minecraft.world.entity.EntityType;
@@ -115,7 +114,6 @@ import org.bukkit.entity.TippedArrow;
 import org.bukkit.entity.Trident;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.event.weather.LightningStrikeEvent;
-import org.bukkit.event.world.SpawnChangeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 import org.bukkit.generator.BiomeProvider;
 import org.bukkit.generator.BlockPopulator;
@@ -498,27 +496,26 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     public boolean refreshChunk(int x, int z) {
         ChunkHolder playerChunk = this.world.getChunkSource().chunkMap.getVisibleChunkIfPresent(ChunkPos.asLong(x, z));
         if (playerChunk == null) return false;
-
         // Paper start - rewrite player chunk loader
         net.minecraft.world.level.chunk.LevelChunk chunk = playerChunk.getSendingChunk();
         if (chunk == null) {
             return false;
         }
         // Paper end - rewrite player chunk loader
-                List<ServerPlayer> playersInRange = playerChunk.playerProvider.getPlayers(playerChunk.getPos(), false);
-                if (playersInRange.isEmpty()) return true; // Paper - rewrite player chunk loader
-
-                // Paper start - Anti-Xray - Bypass
-                Map<Object, ClientboundLevelChunkWithLightPacket> refreshPackets = new HashMap<>();
-                for (ServerPlayer player : playersInRange) {
-                    if (player.connection == null) continue;
-
-                    Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
-                    player.connection.send(refreshPackets.computeIfAbsent(shouldModify, s -> { // Use connection to prevent creating firing event
-                        return new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, true, (Boolean) s);
-                    }));
-                    // Paper end
-                }
+        List<ServerPlayer> playersInRange = playerChunk.playerProvider.getPlayers(playerChunk.getPos(), false, !this.getHandle().sukiConfig().viewDistance.ifCanSeeButNotTracking.sendChunkRefresh); // Suki - per-player track and see view distance
+        if (playersInRange.isEmpty()) return true;
+
+        // Paper start - Anti-Xray - Bypass
+        Map<Object, ClientboundLevelChunkWithLightPacket> refreshPackets = new HashMap<>();
+        for (ServerPlayer player : playersInRange) {
+            if (player.connection == null) continue;
+
+            Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
+            player.connection.send(refreshPackets.computeIfAbsent(shouldModify, s -> { // Use connection to prevent creating firing event
+                return new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, true, (Boolean) s);
+            }));
+            // Paper end
+        }
         // Paper - rewrite player chunk loader
 
         return true;
@@ -2254,7 +2251,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     // Spigot start
     @Override
     public int getViewDistance() {
-        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance(); // Paper - replace old player chunk management
+        return getHandle().getChunkSource().chunkMap.getVanillaWorldViewDistance(); // Paper - replace old player chunk management // Suki - per-player view distance
     }
 
     @Override
@@ -2269,7 +2266,8 @@ public class CraftWorld extends CraftRegionAccessor implements World {
             throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
         }
         net.minecraft.server.level.ChunkMap chunkMap = getHandle().getChunkSource().chunkMap;
-        chunkMap.setViewDistance(viewDistance);
+        chunkMap.setVanillaWorldViewDistance(viewDistance); // Suki - per-player view distance
+        // Paper end - replace old player chunk management
     }
 
     @Override
@@ -2293,12 +2291,15 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public int getSendViewDistance() {
-        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance();
+        // Suki start - per-player view distance
+//        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance();
+        return this.getViewDistance() - 1;
+        // Suki end - per-player view distance
     }
 
     @Override
     public void setSendViewDistance(int viewDistance) {
-        getHandle().getChunkSource().chunkMap.playerChunkManager.setSendDistance(viewDistance);
+//        getHandle().getChunkSource().chunkMap.playerChunkManager.setSendDistance(viewDistance); // Suki - per-player view distance
     }
     // Paper end - view distance api
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 7e2dbcb4e9784682a7ecc5af3c2051c83c7d7b09..773c8df08d84ee6c50e87564fc175aa58ab41711 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -183,26 +183,28 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         this.firstPlayed = System.currentTimeMillis();
     }
 
+    // Suki start - per-player view distance
     // Paper start - implement view distances
     @Override
     public int getViewDistance() {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            return chunkMap.playerChunkManager.getTargetNoTickViewDistance();
-        }
-        return data.getTargetNoTickViewDistance();
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            return chunkMap.playerChunkManager.getTargetNoTickViewDistance();
+//        }
+//        return data.getTargetNoTickViewDistance();
+        return this.getLoadViewDistance();
     }
 
     @Override
     public void setViewDistance(int viewDistance) {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            throw new IllegalStateException("Player is not attached to world");
-        }
-
-        data.setTargetNoTickViewDistance(viewDistance);
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            throw new IllegalStateException("Player is not attached to world");
+//        }
+//
+//        data.setTargetNoTickViewDistance(viewDistance);
     }
 
     @Override
@@ -228,35 +230,53 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public int getNoTickViewDistance() {
-        return this.getViewDistance();
+//        return this.getViewDistance();
+        return this.getLoadViewDistance();
     }
 
     @Override
     public void setNoTickViewDistance(int viewDistance) {
-        this.setViewDistance(viewDistance);
+//        this.setViewDistance(viewDistance);
     }
 
     @Override
     public int getSendViewDistance() {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            return chunkMap.playerChunkManager.getTargetSendDistance();
-        }
-        return data.getTargetSendViewDistance();
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            return chunkMap.playerChunkManager.getTargetSendDistance();
+//        }
+//        return data.getTargetSendViewDistance();
+        return this.getSeeViewDistance();
     }
 
     @Override
     public void setSendViewDistance(int viewDistance) {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            throw new IllegalStateException("Player is not attached to world");
-        }
+//        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
+//        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
+//        if (data == null) {
+//            throw new IllegalStateException("Player is not attached to world");
+//        }
+//
+//        data.setTargetSendViewDistance(viewDistance);
+    }
 
-        data.setTargetSendViewDistance(viewDistance);
+    @Override
+    public int getTrackViewDistance() {
+        return this.getHandle().getTrackViewDistance();
+    }
+
+    @Override
+    public int getSeeViewDistance() {
+        return this.getHandle().getSeeViewDistance();
+    }
+
+    @Override
+    public int getLoadViewDistance() {
+        return this.getHandle().getLoadViewDistance();
     }
     // Paper end - implement view distances
+    // Suki end - per-player view distance
 
     public GameProfile getProfile() {
         return this.getHandle().getGameProfile();
diff --git a/src/main/java/org/sucraft/suki/configuration/SukiGlobalConfiguration.java b/src/main/java/org/sucraft/suki/configuration/SukiGlobalConfiguration.java
index 5a1e50c3b65be575ab24bb04d7b0162b2d32dcad..99ee7401b4c9742389d1f1536e7f111a860391ee 100644
--- a/src/main/java/org/sucraft/suki/configuration/SukiGlobalConfiguration.java
+++ b/src/main/java/org/sucraft/suki/configuration/SukiGlobalConfiguration.java
@@ -4,6 +4,7 @@ package org.sucraft.suki.configuration;
 
 import io.papermc.paper.configuration.Configuration;
 import io.papermc.paper.configuration.ConfigurationPart;
+import net.minecraft.server.level.ServerPlayer;
 import org.spongepowered.configurate.objectmapping.meta.Setting;
 
 @SuppressWarnings({"CanBeFinal", "FieldCanBeLocal", "FieldMayBeFinal", "NotNullFieldNotInitialized", "InnerClassMayBeStatic"})
@@ -104,7 +105,7 @@ public class SukiGlobalConfiguration extends ConfigurationPart {
 
     // Suki end - no signed chat
 
-    // Suki start - allow invalid client view distance
+    // Suki start - allow invalid client view distance, per-player track and see view distance
 
     public ViewDistance viewDistance;
 
@@ -112,9 +113,57 @@ public class SukiGlobalConfiguration extends ConfigurationPart {
 
         public boolean allowInvalidClientViewDistance = false;
 
+        public Track track;
+
+        public class Track extends TrackOrSee {
+
+            @Override
+            protected void onMaxTotalChunksChanged() {
+                ServerPlayer.maxTrackViewDistanceDueToTotalTrackedChunksMayHaveChanged();
+            }
+
+        }
+
+        public See see;
+
+        public class See extends TrackOrSee {
+
+            @Override
+            protected void onMaxTotalChunksChanged() {
+                ServerPlayer.maxSeeViewDistanceDueToTotalSeenChunksMayHaveChanged();
+            }
+
+        }
+
+        public abstract class TrackOrSee extends ConfigurationPart {
+
+            /**
+             * -1 indicates no limit
+             *
+             * @deprecated Because this variable should not be used:
+             * use getMaxTotalChunks and setMaxTotalChunks instead
+             */
+            @Deprecated
+            public int maxTotalChunks = -1;
+
+            public int getMaxTotalChunks() {
+                return maxTotalChunks;
+            }
+
+            protected abstract void onMaxTotalChunksChanged();
+
+            public void setMaxTotalChunks(int maxTotalChunks) {
+                if (this.maxTotalChunks != maxTotalChunks) {
+                    this.maxTotalChunks = maxTotalChunks;
+                    onMaxTotalChunksChanged();
+                }
+            }
+
+        }
+
     }
 
-    // Suki end - allow invalid client view distance
+    // Suki end - allow invalid client view distance, per-player track and see view distance
 
     // Suki start - configurable keep-alive
 
diff --git a/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java b/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java
index b423c6df22aa995517234164b4222bedce4c2845..f5b51d75d57a5ede752b4b34af1f7242dcf226c1 100644
--- a/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java
+++ b/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java
@@ -9,6 +9,9 @@ import io.papermc.paper.configuration.NestedSetting;
 import io.papermc.paper.configuration.PaperConfigurations;
 import it.unimi.dsi.fastutil.Pair;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.slf4j.Logger;
 import org.spigotmc.SpigotWorldConfig;
 import org.spongepowered.configurate.objectmapping.meta.Setting;
@@ -401,5 +404,160 @@ public class SukiWorldConfiguration extends ConfigurationPart {
 
     // Suki end - more entity activation configuration
 
+    // Suki start - per-player view distance
+
+    public ViewDistance viewDistance;
+
+    public class ViewDistance extends ConfigurationPart {
+
+        public Track track;
+
+        public class Track extends UpdateAllPlayersOnChangeViewDistance {
+
+            @Override
+            protected void updatePlayer(ServerPlayer player) {
+                player.trackViewDistanceMayHaveChanged();
+            }
+
+        }
+
+        public See see;
+
+        public class See extends UpdateAllPlayersOnChangeViewDistance {
+
+            @Override
+            protected void updatePlayer(ServerPlayer player) {
+                player.seeViewDistanceMayHaveChanged();
+            }
+
+        }
+
+        public Load load;
+
+        public class Load extends UpdateAllPlayersOnChangeViewDistance {
+
+            @Override
+            protected void updatePlayer(ServerPlayer player) {
+                player.loadViewDistanceMayHaveChanged();
+            }
+
+            /**
+             * @deprecated Because this variable should not be used:
+             * use getLimitBySeeViewDistance and setLimitBySeeViewDistance instead
+             */
+            @Deprecated
+            public boolean limitBySeeViewDistance = false;
+
+            public boolean getLimitBySeeViewDistance() {
+                return limitBySeeViewDistance;
+            }
+
+            public void setLimitBySeeViewDistance(boolean limitBySeeViewDistance) {
+                this.limitBySeeViewDistance = limitBySeeViewDistance;
+                updateAllPlayers();
+            }
+
+            /**
+             * In ticks
+             * <br>
+             * A nonpositive integer disables this feature
+             */
+            public transient int printLoadedChunksInterval = -1;
+
+        }
+
+        public abstract class UpdateAllPlayersOnChangeViewDistance extends SpecificDistance {
+
+            protected abstract void updatePlayer(ServerPlayer player);
+
+            protected void updateAllPlayers() {
+                Bukkit.getOnlinePlayers().forEach(player -> updatePlayer(((CraftPlayer) player).getHandle()));
+            }
+
+            @Override
+            protected void onMaxChanged() {
+                updateAllPlayers();
+            }
+
+            @Override
+            protected void onLimitByClientViewDistanceChanged() {
+                updateAllPlayers();
+            }
+
+        }
+
+        public abstract class SpecificDistance extends ConfigurationPart {
+
+            /**
+             * @deprecated Because this variable should not be used:
+             * use getPerPlayer instead
+             */
+            @Deprecated
+            public boolean perPlayer = false;
+
+            public boolean getPerPlayer() {
+                return perPlayer;
+            }
+
+            /**
+             * This is only used if perPlayer is true
+             * <br>
+             * -1 indicates no limit (it is still limited by the Bukkit world view distance)
+             * <br>
+             * Valid values are -1,
+             * or an integer in the range [2, 32] for the track and see view distances and in the range [3, 33] for the
+             * load view distance
+             *
+             * @deprecated Because this variable should not be used:
+             * use getMax and setMax instead
+             */
+            @Deprecated
+            public int max = -1;
+
+            public int getMax() {
+                return max;
+            }
+
+            protected abstract void onMaxChanged();
+
+            public void setMax(int max) {
+                this.max = max;
+                onMaxChanged();
+            }
+
+            /**
+             * @deprecated Because this variable should not be used:
+             * use getLimitByClientViewDistance and setLimitByClientViewDistance instead
+             */
+            @Deprecated
+            public boolean limitByClientViewDistance = false;
+
+            public boolean getLimitByClientViewDistance() {
+                return limitByClientViewDistance;
+            }
+
+            protected abstract void onLimitByClientViewDistanceChanged();
+
+            public void setLimitByClientViewDistance(boolean limitByClientViewDistance) {
+                this.limitByClientViewDistance = limitByClientViewDistance;
+                onLimitByClientViewDistanceChanged();
+            }
+
+        }
+
+        public IfCanSeeButNotTracking ifCanSeeButNotTracking;
+
+        public class IfCanSeeButNotTracking extends ConfigurationPart {
+
+            public boolean sendChunkRefresh = true;
+            public boolean sendWitherSpawnSound = true;
+            public boolean sendEnderDragonSpawnSound = true;
+            public boolean sendEndPortalFillSound = true;
+            
+        }
+
+    }
+
+    // Suki end - per-player view distance
 
 }
