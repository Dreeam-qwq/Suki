From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Tue, 20 Sep 2022 03:14:49 +0200
Subject: [PATCH] Configurable tick oversleep


diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 673a2999165b059308cd306e846206dcea4a3c83..dba3e8242ad39cd008aab828169839eb3f1a0bed 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -13,6 +13,7 @@ import com.mojang.authlib.GameProfileRepository;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.configuration.GlobalConfiguration;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import java.awt.image.BufferedImage;
 import java.io.BufferedWriter;
@@ -181,6 +182,7 @@ import org.bukkit.event.server.ServerLoadEvent;
 // CraftBukkit end
 
 import co.aikar.timings.MinecraftTimings; // Paper
+import org.sucraft.suki.configuration.SukiGlobalConfiguration;
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<Runnable> implements CommandSource, AutoCloseable { // Patina
 
@@ -254,6 +256,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<Runnab
     public final Thread serverThread;
     private long nextTickTime;
     private long delayedTasksMaxNextTickTime;
+    // Suki start - TPS options - configurable tick oversleep
+    private double unfinishedTicksStateForOversleepPlannedAfterLastTickEnd;
+    private double unfinishedTicksStateForOversleepMaxAfterNextTickStart;
+    // Suki end - TPS options - configurable tick oversleep
     private boolean mayHaveDelayedTasks;
     private final PackRepository packRepository;
     private final ServerScoreboard scoreboard;
@@ -1189,7 +1195,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<Runnab
                 lastProperTickTime = java.time.Duration.ofNanos(System.nanoTime() - properTickStart); // Suki - last tick time API
                 this.profiler.popPush("nextTickWait");
                 this.mayHaveDelayedTasks = true;
-                this.delayedTasksMaxNextTickTime = Math.max(Util.getMillis() + 50L, this.nextTickTime);
+                // Suki start - TPS options - configurable tick oversleep
+                var oversleepConfig = SukiGlobalConfiguration.get().tps.oversleep.dynamic;
+                long oversleepPlannedAfterLastTickEnd = (long) Math.round(Math.min(oversleepConfig.plannedAfterLastTickEnd.max, oversleepConfig.plannedAfterLastTickEnd.min + Math.max(0.0, this.unfinishedTicksStateForOversleepPlannedAfterLastTickEnd)));
+                long oversleepMaxAfterNextTickStart = (long) Math.round(Math.min(oversleepConfig.maxAfterNextTickStart.max, oversleepConfig.maxAfterNextTickStart.min + Math.max(0.0, this.unfinishedTicksStateForOversleepMaxAfterNextTickStart)));
+                this.delayedTasksMaxNextTickTime = Math.min(Math.max(Util.getMillis() + oversleepPlannedAfterLastTickEnd, this.nextTickTime), this.nextTickTime + oversleepMaxAfterNextTickStart);
+                // Suki end - TPS options - configurable tick oversleep
                 this.waitUntilNextTick();
                 this.profiler.pop();
                 this.endMetricsRecordingTick();
@@ -1286,11 +1297,27 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<Runnab
     // Paper start
     boolean isOversleep = false;
     private boolean canOversleep() {
-        return this.mayHaveDelayedTasks && Util.getMillis() < this.delayedTasksMaxNextTickTime;
+        // Suki start - TPS options - configurable tick oversleep
+        if (!this.mayHaveDelayedTasks) {
+            return false;
+        }
+        if (this.getPendingTasksCount() == 0) {
+            return Util.getMillis() < this.nextTickTime - SukiGlobalConfiguration.get().tps.oversleep.startNextTickEarlyIfNoPendingTasks;
+        }
+        return Util.getMillis() < this.delayedTasksMaxNextTickTime;
+        // Suki end - TPS options - configurable tick oversleep
     }
 
     private boolean canSleepForTickNoOversleep() {
-        return this.forceTicks || this.runningTask() || Util.getMillis() < this.nextTickTime;
+        // Suki start - TPS options - configurable tick oversleep
+        if (this.forceTicks || this.runningTask()) {
+            return true;
+        }
+        if (this.getPendingTasksCount() == 0) {
+            return Util.getMillis() < this.nextTickTime - SukiGlobalConfiguration.get().tps.oversleep.startNextTickEarlyIfNoPendingTasks;
+        }
+        return Util.getMillis() < this.nextTickTime;
+        // Suki end - TPS options - configurable tick oversleep
     }
     // Paper end
 
@@ -1316,7 +1343,18 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<Runnab
     protected void waitUntilNextTick() {
         //this.executeAll(); // Paper - move this into the tick method for timings
         long tickOversleepStart = System.nanoTime(); // Suki - last tick time API
+        this.finishedAllTasksAtSomePoint = false; // Suki - TPS options - configurable tick oversleep
         this.managedBlockUntilNextTick(() -> !this.canSleepForTickNoOversleep()); // Suki - informed event loop task poll
+        // Suki start - TPS options - configurable tick oversleep
+        var oversleepConfig = SukiGlobalConfiguration.get().tps.oversleep.dynamic;
+        if (!finishedAllTasksAtSomePoint) {
+            this.unfinishedTicksStateForOversleepPlannedAfterLastTickEnd = Math.min(oversleepConfig.plannedAfterLastTickEnd.max - oversleepConfig.plannedAfterLastTickEnd.min, this.unfinishedTicksStateForOversleepPlannedAfterLastTickEnd + oversleepConfig.plannedAfterLastTickEnd.increasePerUnfinishedTick);
+            this.unfinishedTicksStateForOversleepMaxAfterNextTickStart = Math.min(oversleepConfig.maxAfterNextTickStart.max - oversleepConfig.maxAfterNextTickStart.min, this.unfinishedTicksStateForOversleepMaxAfterNextTickStart + oversleepConfig.maxAfterNextTickStart.increasePerUnfinishedTick);
+        } else {
+            this.unfinishedTicksStateForOversleepPlannedAfterLastTickEnd = Math.max(-oversleepConfig.plannedAfterLastTickEnd.ticksImmuneFromIncrease * oversleepConfig.plannedAfterLastTickEnd.increasePerUnfinishedTick, this.unfinishedTicksStateForOversleepPlannedAfterLastTickEnd - oversleepConfig.plannedAfterLastTickEnd.decreasePerFinishedTick);
+            this.unfinishedTicksStateForOversleepMaxAfterNextTickStart = Math.max(-oversleepConfig.maxAfterNextTickStart.ticksImmuneFromIncrease * oversleepConfig.maxAfterNextTickStart.increasePerUnfinishedTick, this.unfinishedTicksStateForOversleepMaxAfterNextTickStart - oversleepConfig.maxAfterNextTickStart.decreasePerFinishedTick);
+        }
+        // Suki end - TPS options - configurable tick oversleep
         lastTickOversleepTime = java.time.Duration.ofNanos(System.nanoTime() - tickOversleepStart); // Suki - last tick time API
     }
 
diff --git a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
index 9f442bc3fc7295b152ea3180971c257525cce602..529a877050e99e261c833b15ac92270ffbabd3f4 100644
--- a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
+++ b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
@@ -28,6 +28,7 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     public static final long DEFAULT_POLL_TIMEOUT_MICROS = 100L; // JettPack
     public long pollTimeoutMicros = DEFAULT_POLL_TIMEOUT_MICROS;
     // Suki end - informed event loop task poll
+    protected boolean finishedAllTasksAtSomePoint; // Suki - TPS options - configurable tick oversleep
 
     protected BlockableEventLoop(String name) {
         this.name = name;
@@ -160,6 +161,7 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
         if (this.next != null) {
             throw new IllegalStateException("next != null");
         }
+        this.finishedAllTasksAtSomePoint = true; // Suki - TPS options - configurable tick oversleep
         try {
             this.next = this.pendingRunnables.poll(pollTimeoutMicros, TimeUnit.MICROSECONDS); // Suki - informed event loop task poll
             return;
diff --git a/src/main/java/org/sucraft/suki/configuration/SukiGlobalConfiguration.java b/src/main/java/org/sucraft/suki/configuration/SukiGlobalConfiguration.java
index e183225a6371b70eb82be961dcc613ba5f0b68ed..942156d2816f5cc7f0937843954f09135ca76855 100644
--- a/src/main/java/org/sucraft/suki/configuration/SukiGlobalConfiguration.java
+++ b/src/main/java/org/sucraft/suki/configuration/SukiGlobalConfiguration.java
@@ -4,7 +4,7 @@ package org.sucraft.suki.configuration;
 
 import io.papermc.paper.configuration.Configuration;
 import io.papermc.paper.configuration.ConfigurationPart;
-import io.papermc.paper.configuration.GlobalConfiguration;
+import org.checkerframework.checker.units.qual.A;
 import org.spongepowered.configurate.objectmapping.meta.Setting;
 
 @SuppressWarnings({"CanBeFinal", "FieldCanBeLocal", "FieldMayBeFinal", "NotNullFieldNotInitialized", "InnerClassMayBeStatic"})
@@ -126,4 +126,61 @@ public class SukiGlobalConfiguration extends ConfigurationPart {
 
     // Suki end - configurable keep-alive
 
+    // Suki start - TPS options
+
+    public Tps tps;
+
+    public class Tps extends ConfigurationPart {
+
+        public Oversleep oversleep;
+
+        public class Oversleep extends ConfigurationPart {
+
+            public int startNextTickEarlyIfNoPendingTasks = 2;
+
+            public Dynamic dynamic;
+
+            public class Dynamic extends ConfigurationPart {
+
+                public PlannedAfterLastTickEnd plannedAfterLastTickEnd;
+
+                /**
+                 * The time that is planned for oversleep after the last tick's end
+                 * <br>
+                 * In milliseconds
+                 */
+                public class PlannedAfterLastTickEnd extends ConfigurationPart {
+
+                    public double min = 0;
+                    public double max = 50;
+                    public double increasePerUnfinishedTick = 1;
+                    public double decreasePerFinishedTick = 3.0;
+                    public int ticksImmuneFromIncrease = 2;
+
+                }
+
+                public MaxAfterNextTickStart maxAfterNextTickStart;
+
+                /**
+                 * The maximum time to oversleep after the intended next tick's start
+                 * <br>
+                 * In milliseconds
+                 */
+                public class MaxAfterNextTickStart extends ConfigurationPart {
+
+                    public double min = 0;
+                    public double max = 50;
+                    public double increasePerUnfinishedTick = 0.5;
+                    public double decreasePerFinishedTick = 3.0;
+                    public int ticksImmuneFromIncrease = 10;
+
+                }
+
+            }
+        }
+
+    }
+
+    // Suki end - TPS options
+
 }
