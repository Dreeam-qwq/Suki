From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Martijn Muijsers <martijnmuijsers@live.nl>
Date: Sat, 25 Feb 2023 17:31:35 +0100
Subject: [PATCH] Per-player load, see and track view distance

License: AGPL-3.0 (https://www.gnu.org/licenses/agpl-3.0.html)
Suki - https://github.com/SuCraft/Suki

diff --git a/src/main/java/co/aikar/timings/TimingsExport.java b/src/main/java/co/aikar/timings/TimingsExport.java
index 5b593c4a7991fefe4bdd881a2824e8f4052c5329..b9ec0206bfdeea27bd68c1b3a8d7832ee86f0c57 100644
--- a/src/main/java/co/aikar/timings/TimingsExport.java
+++ b/src/main/java/co/aikar/timings/TimingsExport.java
@@ -227,8 +227,11 @@ public class TimingsExport extends Thread {
                 })),
                 // Paper start - replace chunk loader system
                 pair("ticking-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance()),
-                pair("no-ticking-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance()),
-                pair("sending-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance())
+                // Suki start - per-player track and see view distance
+                pair("max-track-distance", world.sukiConfig().viewDistance.track.getMax()),
+                pair("max-see-distance", world.sukiConfig().viewDistance.see.getMax()),
+                pair("max-load-distance", world.sukiConfig().viewDistance.load.getMax())
+                // Suki end - per-player track and see view distance
                 // Paper end - replace chunk loader system
             ));
         }));
diff --git a/src/main/java/co/aikar/timings/WorldTimingsHandler.java b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
index fe79c0add4f7cb18d487c5bb9415c40c5b551ea2..dda0f831d0e3768f5798705695742d0c9052f963 100644
--- a/src/main/java/co/aikar/timings/WorldTimingsHandler.java
+++ b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
@@ -44,6 +44,28 @@ public class WorldTimingsHandler {
     public final Timing broadcastChunkUpdates;
     public final Timing countNaturalMobs;
 
+    // Suki start - per-player view distance
+//    public final Timing getPlayersNearChunkForSending;
+    public final Timing chunkMapPlayerMove;
+//    public final Timing chunkMapPlayerMoveUpdatePos;
+//    public final Timing chunkMapPlayerMoveUpdateDistanceManager;
+//    public final Timing chunkMapPlayerMoveUpdatePlayerMap;
+//    public final Timing chunkMapUpdatePlayerMaps;
+    public final Timing playerChunkLoaderUpdate;
+    public final Timing playerChunkLoaderUpdateGetViewDistances;
+    public final Timing playerChunkLoaderUpdateDecideWhetherToRecalculate;
+//    public final Timing chunkMapPlayerMoveUpdateChunkTrackingOrSeeing;
+//    public final Timing chunkMapPlayerMoveSortChunksForTrackAndSee;
+    public final Timing computeTrackViewDistance;
+    public final Timing computeSeeViewDistance;
+    public final Timing computeLoadViewDistance;
+    public final Timing trackViewDistanceMayHaveChanged;
+    public final Timing seeViewDistanceMayHaveChanged;
+    public final Timing loadViewDistanceMayHaveChanged;
+    public final Timing processTrackViewDistanceChange;
+    public final Timing processSeeViewDistanceChange;
+    // Suki end - per-player view distance
+
     public final Timing chunkLoad;
     public final Timing chunkLoadPopulate;
     public final Timing syncChunkLoad;
@@ -119,6 +141,27 @@ public class WorldTimingsHandler {
         broadcastChunkUpdates = Timings.ofSafe(name + "Broadcast chunk updates");
         countNaturalMobs = Timings.ofSafe(name + "Count natural mobs");
 
+        // Suki start - per-player view distance
+//        getPlayersNearChunkForSending = Timings.ofSafe("Get players near chunk for sending");
+        chunkMapPlayerMove = Timings.ofSafe("Chunk map player move");
+//        chunkMapPlayerMoveUpdatePos = Timings.ofSafe("Chunk map player move - update pos");
+//        chunkMapPlayerMoveUpdateDistanceManager = Timings.ofSafe("Chunk map player move - update distance manager");
+//        chunkMapPlayerMoveUpdatePlayerMap = Timings.ofSafe("Chunk map player move - update player map");
+//        chunkMapUpdatePlayerMaps = Timings.ofSafe("Chunk map update player maps");
+        playerChunkLoaderUpdate = Timings.ofSafe("PlayerChunkLoader update");
+        playerChunkLoaderUpdateGetViewDistances = Timings.ofSafe("PlayerChunkLoader update - get view distances");
+        playerChunkLoaderUpdateDecideWhetherToRecalculate = Timings.ofSafe("PlayerChunkLoader update - decide whether to recalculate");
+//        chunkMapPlayerMoveUpdateChunkTrackingOrSeeing = Timings.ofSafe("Chunk map player move - update chunk tracking or seeing");
+//        chunkMapPlayerMoveSortChunksForTrackAndSee = Timings.ofSafe("Chunk map player move - sort chunks for track and see");
+        computeTrackViewDistance = Timings.ofSafe("Compute track view distance");
+        computeSeeViewDistance = Timings.ofSafe("Compute see view distance");
+        computeLoadViewDistance = Timings.ofSafe("Compute load view distance");
+        trackViewDistanceMayHaveChanged = Timings.ofSafe("Track view distance may have changed");
+        seeViewDistanceMayHaveChanged = Timings.ofSafe("See view distance may have changed");
+        loadViewDistanceMayHaveChanged = Timings.ofSafe("Load view distance may have changed");
+        processTrackViewDistanceChange = Timings.ofSafe("Process track view distance change");
+        processSeeViewDistanceChange = Timings.ofSafe("Process see view distance change");
+        // Suki end - per-player view distance
 
         miscMobSpawning = Timings.ofSafe(name + "Mob spawning - Misc");
 
diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index e77972c4c264100ffdd824bfa2dac58dbbc6d678..345c6e49ba306b081ffb741703aa91b7fc9c2bca 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -24,6 +24,7 @@ import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.entity.Player;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
 import java.util.TreeSet;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -49,32 +50,6 @@ public final class PlayerChunkLoader {
         return data.getTargetTickViewDistance();
     }
 
-    public static int getLoadViewDistance(final Player player) {
-        return getLoadViewDistance(((CraftPlayer)player).getHandle());
-    }
-
-    public static int getLoadViewDistance(final ServerPlayer player) {
-        final ServerLevel level = (ServerLevel)player.level;
-        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
-        if (data == null) {
-            return level.chunkSource.chunkMap.playerChunkManager.getLoadDistance();
-        }
-        return data.getLoadDistance();
-    }
-
-    public static int getSendViewDistance(final Player player) {
-        return getSendViewDistance(((CraftPlayer)player).getHandle());
-    }
-
-    public static int getSendViewDistance(final ServerPlayer player) {
-        final ServerLevel level = (ServerLevel)player.level;
-        final PlayerLoaderData data = level.chunkSource.chunkMap.playerChunkManager.getData(player);
-        if (data == null) {
-            return level.chunkSource.chunkMap.playerChunkManager.getTargetSendDistance();
-        }
-        return data.getTargetSendViewDistance();
-    }
-
     protected final ChunkMap chunkMap;
     protected final Reference2ObjectLinkedOpenHashMap<ServerPlayer, PlayerLoaderData> playerMap = new Reference2ObjectLinkedOpenHashMap<>(512, 0.7f);
     protected final ReferenceLinkedOpenHashSet<PlayerLoaderData> chunkSendQueue = new ReferenceLinkedOpenHashSet<>(512, 0.7f);
@@ -135,7 +110,15 @@ public final class PlayerChunkLoader {
     /**
      * The chunks to be sent to players, provided they're send-ready. Send-ready means the chunk and its 1 radius neighbours are loaded.
      */
-    public final PlayerAreaMap broadcastMap;
+    // Suki start - per-player track and see view distance
+    public final PlayerAreaMap broadcastMapForTracking;
+    public final PlayerAreaMap broadcastMapForSeeing;
+
+    public PlayerAreaMap getBroadcastMap(final boolean concernsTracking) {
+        return concernsTracking ? this.broadcastMapForTracking : this.broadcastMapForSeeing;
+    }
+
+    // Suki end - per-player track and see view distance
 
     /**
      * The chunks to be brought up to send-ready status. Send-ready means the chunk and its 1 radius neighbours are loaded.
@@ -153,16 +136,6 @@ public final class PlayerChunkLoader {
      */
     public final PlayerAreaMap tickMap;
 
-    /**
-     * -1 if defaulting to [load distance], else always in [2, load distance]
-     */
-    protected int rawSendDistance = -1;
-
-    /**
-     * -1 if defaulting to [tick view distance + 1], else always in [tick view distance + 1, 32 + 1]
-     */
-    protected int rawLoadDistance = -1;
-
     /**
      * Never -1, always in [2, 32]
      */
@@ -178,48 +151,6 @@ public final class PlayerChunkLoader {
         this.setTickDistance(distance);
     }
 
-    public int getTargetNoTickViewDistance() {
-        return this.getLoadDistance() - 1;
-    }
-
-    public void setTargetNoTickViewDistance(final int distance) {
-        this.setLoadDistance(distance == -1 ? -1 : distance + 1);
-    }
-
-    public int getTargetSendDistance() {
-        return this.rawSendDistance == -1 ? this.getLoadDistance() : this.rawSendDistance;
-    }
-
-    public void setTargetSendDistance(final int distance) {
-        this.setSendDistance(distance);
-    }
-
-    // internal methods
-
-    public int getSendDistance() {
-        final int loadDistance = this.getLoadDistance();
-        return this.rawSendDistance == -1 ? loadDistance : Math.min(this.rawSendDistance, loadDistance);
-    }
-
-    public void setSendDistance(final int distance) {
-        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-            throw new IllegalArgumentException("Send distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
-        }
-        this.rawSendDistance = distance;
-    }
-
-    public int getLoadDistance() {
-        final int tickDistance = this.getTickDistance();
-        return this.rawLoadDistance == -1 ? tickDistance + 1 : Math.max(tickDistance + 1, this.rawLoadDistance);
-    }
-
-    public void setLoadDistance(final int distance) {
-        if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-            throw new IllegalArgumentException("Load distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + ", or -1, got: " + distance);
-        }
-        this.rawLoadDistance = distance;
-    }
-
     public int getTickDistance() {
         return this.rawTickDistance;
     }
@@ -256,12 +187,20 @@ public final class PlayerChunkLoader {
 
     public PlayerChunkLoader(final ChunkMap chunkMap, final PooledLinkedHashSets<ServerPlayer> pooledHashSets) {
         this.chunkMap = chunkMap;
-        this.broadcastMap = new PlayerAreaMap(pooledHashSets,
+        // Suki start - player track and see view distance
+        this.broadcastMapForTracking = new PlayerAreaMap(pooledHashSets,
                 null,
                 (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
                  com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
-                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ);
+                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ, true);
                 });
+        this.broadcastMapForSeeing = new PlayerAreaMap(pooledHashSets,
+                null,
+                (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+                 com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> newState) -> {
+                    PlayerChunkLoader.this.onChunkLeave(player, rangeX, rangeZ, false);
+                });
+        // Suki end - player track and see view distance
         this.loadMap = new PlayerAreaMap(pooledHashSets,
                 null,
                 (ServerPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
@@ -311,12 +250,16 @@ public final class PlayerChunkLoader {
     protected final LongOpenHashSet isTargetedForPlayerLoad = new LongOpenHashSet();
     protected final LongOpenHashSet chunkTicketTracker = new LongOpenHashSet();
 
-    public boolean isChunkNearPlayers(final int chunkX, final int chunkZ) {
-        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.broadcastMap.getObjectsInRange(chunkX, chunkZ);
+    // Suki start - per-player track and see view distance
+
+    public boolean isChunkNearPlayers(final int chunkX, final int chunkZ, boolean concernsTracking) {
+        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.getBroadcastMap(concernsTracking).getObjectsInRange(chunkX, chunkZ);
 
         return playersInSendRange != null;
     }
 
+    // Suki end - per-player track and see view distance
+
     public void onChunkPostProcessing(final int chunkX, final int chunkZ) {
         this.onChunkSendReady(chunkX, chunkZ);
     }
@@ -348,34 +291,38 @@ public final class PlayerChunkLoader {
         return levelChunk != null && levelChunk.isPostProcessingDone && this.isTargetedForPlayerLoad.contains(key);
     }
 
-    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean borderOnly) {
-        return borderOnly ? this.isChunkSentBorderOnly(player, chunkX, chunkZ) : this.isChunkSent(player, chunkX, chunkZ);
+    // Suki start - per-player track and see view distance
+
+    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean borderOnly, final boolean concernsTracking) {
+        return borderOnly ? this.isChunkSentBorderOnly(player, chunkX, chunkZ, concernsTracking) : this.isChunkSent(player, chunkX, chunkZ, concernsTracking);
     }
 
-    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public boolean isChunkSent(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) {
         final PlayerLoaderData data = this.playerMap.get(player);
         if (data == null) {
             return false;
         }
 
-        return data.hasSentChunk(chunkX, chunkZ);
+        return data.hasSentChunk(chunkX, chunkZ, concernsTracking);
     }
 
-    public boolean isChunkSentBorderOnly(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public boolean isChunkSentBorderOnly(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) {
         final PlayerLoaderData data = this.playerMap.get(player);
         if (data == null) {
             return false;
         }
 
-        final boolean center = data.hasSentChunk(chunkX, chunkZ);
+        final boolean center = data.hasSentChunk(chunkX, chunkZ, concernsTracking);
         if (!center) {
             return false;
         }
 
-        return !(data.hasSentChunk(chunkX - 1, chunkZ) && data.hasSentChunk(chunkX + 1, chunkZ) &&
-            data.hasSentChunk(chunkX, chunkZ - 1) && data.hasSentChunk(chunkX, chunkZ + 1));
+        return !(data.hasSentChunk(chunkX - 1, chunkZ, concernsTracking) && data.hasSentChunk(chunkX + 1, chunkZ, concernsTracking) &&
+            data.hasSentChunk(chunkX, chunkZ - 1, concernsTracking) && data.hasSentChunk(chunkX, chunkZ + 1, concernsTracking));
     }
 
+    // Suki end - per-player track and see view distance
+
     protected int getMaxConcurrentChunkSends() {
         return GlobalConfiguration.get().chunkLoading.maxConcurrentSends;
     }
@@ -400,47 +347,55 @@ public final class PlayerChunkLoader {
     }
 
     public void onChunkSendReady(final int chunkX, final int chunkZ) {
-        final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.broadcastMap.getObjectsInRange(chunkX, chunkZ);
 
-        if (playersInSendRange == null) {
-            return;
-        }
+        // Suki start - per-player track and see view distance
 
-        final Object[] rawData = playersInSendRange.getBackingSet();
-        for (int i = 0, len = rawData.length; i < len; ++i) {
-            final Object raw = rawData[i];
+        for (boolean concernsTracking : new boolean[] {false, true}) {
+            final PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> playersInSendRange = this.getBroadcastMap(concernsTracking).getObjectsInRange(chunkX, chunkZ);
 
-            if (!(raw instanceof ServerPlayer)) {
-                continue;
+            if (playersInSendRange == null) {
+                return;
+            }
+
+            final Object[] rawData = playersInSendRange.getBackingSet();
+            for (int i = 0, len = rawData.length; i < len; ++i) {
+                final Object raw = rawData[i];
+
+                if (!(raw instanceof ServerPlayer)) {
+                    continue;
+                }
+                this.onChunkSendReady((ServerPlayer) raw, chunkX, chunkZ, concernsTracking);
             }
-            this.onChunkSendReady((ServerPlayer)raw, chunkX, chunkZ);
         }
+
+        // Suki end - per-player track and see view distance
+
     }
 
-    public void onChunkSendReady(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public void onChunkSendReady(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) { // Suki - per-player track and see view distance
         final PlayerLoaderData data = this.playerMap.get(player);
 
         if (data == null) {
             return;
         }
 
-        if (data.hasSentChunk(chunkX, chunkZ) || !this.isChunkPlayerLoaded(chunkX, chunkZ)) {
+        if (data.hasSentChunk(chunkX, chunkZ, concernsTracking) || !this.isChunkPlayerLoaded(chunkX, chunkZ)) { // Suki - per-player track and see view distance
             // if we don't have player tickets, then the load logic will pick this up and queue to send
             return;
         }
 
-        if (!data.chunksToBeSent.remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        if (!data.getChunksToBeSent(concernsTracking).remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) { // Suki - per-player track and see view distance
             // don't queue to send, we don't want the chunk
             return;
         }
 
-        final long playerPos = this.broadcastMap.getLastCoordinate(player);
+        final long playerPos = this.broadcastMapForSeeing.getLastCoordinate(player); // Suki - per-player track and see view distance
         final int playerChunkX = CoordinateUtils.getChunkX(playerPos);
         final int playerChunkZ = CoordinateUtils.getChunkZ(playerPos);
         final int manhattanDistance = Math.abs(playerChunkX - chunkX) + Math.abs(playerChunkZ - chunkZ);
 
         final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, 0.0);
-        data.sendQueue.add(holder);
+        data.getSendQueue(concernsTracking).add(holder); // Suki - per-player track and see view distance
     }
 
     public void onChunkLoad(final int chunkX, final int chunkZ) {
@@ -449,14 +404,14 @@ public final class PlayerChunkLoader {
         }
     }
 
-    public void onChunkLeave(final ServerPlayer player, final int chunkX, final int chunkZ) {
+    public void onChunkLeave(final ServerPlayer player, final int chunkX, final int chunkZ, final boolean concernsTracking) { // Suki - per-player track and see view distance
         final PlayerLoaderData data = this.playerMap.get(player);
 
         if (data == null) {
             return;
         }
 
-        data.unloadChunk(chunkX, chunkZ);
+        data.unloadChunk(chunkX, chunkZ, concernsTracking); // Suki - per-player track and see view distance
     }
 
     public void addPlayer(final ServerPlayer player) {
@@ -466,7 +421,7 @@ public final class PlayerChunkLoader {
         }
         final PlayerLoaderData data = new PlayerLoaderData(player, this);
         if (this.playerMap.putIfAbsent(player, data) == null) {
-            data.update();
+            data.update(true); // Suki - per-player view distance
         }
     }
 
@@ -492,14 +447,14 @@ public final class PlayerChunkLoader {
         }
     }
 
-    public void updatePlayer(final ServerPlayer player) {
+    public void updatePlayer(final ServerPlayer player, boolean recalculateMapsIfOnlyViewDistanceChanged) { // Suki - per-player view distance
         TickThread.ensureTickThread("Cannot update player async");
         if (!player.isRealPlayer) {
             return;
         }
         final PlayerLoaderData loaderData = this.playerMap.get(player);
         if (loaderData != null) {
-            loaderData.update();
+            loaderData.update(recalculateMapsIfOnlyViewDistanceChanged); // Suki - per-player view distance
         }
     }
 
@@ -510,7 +465,7 @@ public final class PlayerChunkLoader {
     public void tick() {
         TickThread.ensureTickThread("Cannot tick async");
         for (final PlayerLoaderData data : this.playerMap.values()) {
-            data.update();
+            data.update(true); // Suki - per-player view distance
         }
         this.tickMidTick();
     }
@@ -559,7 +514,14 @@ public final class PlayerChunkLoader {
 
             final PlayerLoaderData data = this.chunkSendQueue.removeFirst();
 
-            final ChunkPriorityHolder queuedSend = data.sendQueue.pollFirst();
+            // Suki start - per-player track and see view distance
+            ChunkPriorityHolder queuedSend = data.getSendQueue(true).pollFirst();
+            boolean concernsTracking = true;
+            if (queuedSend == null) {
+                queuedSend = data.getSendQueue(false).pollFirst();
+                concernsTracking = false;
+            }
+            // Suki end - per-player track and see view distance
             if (queuedSend == null) {
                 concurrentChunkSends.getAndDecrement(); // we never sent, so decrease
                 // stop iterating over players who have nothing to send
@@ -596,7 +558,7 @@ public final class PlayerChunkLoader {
                 }
 
                 concurrentChunkSends.getAndDecrement();
-            });
+            }, concernsTracking);
 
             nextChunkSend = this.getMaxSendAddend() + time;
             if (nextChunkSend - time > 0) {
@@ -776,7 +738,10 @@ public final class PlayerChunkLoader {
         // this is corrected so that 0 is along the positive x-axis
         protected float lastYaw = Float.NEGATIVE_INFINITY;
 
-        protected int lastSendDistance = Integer.MIN_VALUE;
+        // Suki start - per-player track and see view distance
+        protected int lastTrackDistance = Integer.MIN_VALUE;
+        protected int lastSeeDistance = Integer.MIN_VALUE;
+        // Suki end - per-player track and see view distance
         protected int lastLoadDistance = Integer.MIN_VALUE;
         protected int lastTickDistance = Integer.MIN_VALUE;
         protected boolean usingLookingPriority;
@@ -787,28 +752,29 @@ public final class PlayerChunkLoader {
         // warning: modifications of this field must be aware that the loadQueue inside PlayerChunkLoader uses this field
         // in a comparator!
         protected final ArrayDeque<ChunkPriorityHolder> loadQueue = new ArrayDeque<>();
-        protected final LongOpenHashSet sentChunks = new LongOpenHashSet();
-        protected final LongOpenHashSet chunksToBeSent = new LongOpenHashSet();
 
-        protected final TreeSet<ChunkPriorityHolder> sendQueue = new TreeSet<>((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
-            final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
-            if (distanceCompare != 0) {
-                return distanceCompare;
-            }
+        // Suki start - per-player view distance
 
-            final int coordinateXCompare = Integer.compare(p1.chunkX, p2.chunkX);
-            if (coordinateXCompare != 0) {
-                return coordinateXCompare;
-            }
+        protected final LongOpenHashSet sentChunksForTracking = new LongOpenHashSet();
+        protected final LongOpenHashSet chunksToBeSentForTracking = new LongOpenHashSet();
 
-            return Integer.compare(p1.chunkZ, p2.chunkZ);
-        });
+        protected final LongOpenHashSet sentChunksForSeeing = new LongOpenHashSet();
+        protected final LongOpenHashSet chunksToBeSentForSeeing = new LongOpenHashSet();
 
-        protected int sendViewDistance = -1;
-        protected int loadViewDistance = -1;
-        protected int tickViewDistance = -1;
+        private TreeSet<ChunkPriorityHolder> createSendQueue() {
+            return new TreeSet<>((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
+                final int distanceCompare = Integer.compare(p1.manhattanDistanceToPlayer, p2.manhattanDistanceToPlayer);
+                if (distanceCompare != 0) {
+                    return distanceCompare;
+                }
 
-        protected long nextChunkSendTarget;
+                final int coordinateXCompare = Integer.compare(p1.chunkX, p2.chunkX);
+                if (coordinateXCompare != 0) {
+                    return coordinateXCompare;
+                }
+                return Integer.compare(p1.chunkZ, p2.chunkZ);
+            });
+        }
 
         // this interval prevents bursting a lot of chunk loads
         protected final IntervalledCounter ticketAdditionCounterShort = new IntervalledCounter((long)(1.0e6 * 50.0)); // 50ms
@@ -822,35 +788,59 @@ public final class PlayerChunkLoader {
             this.loader = loader;
         }
 
-        // these view distance methods are for api
-        public int getTargetSendViewDistance() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
-            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
-            final int clientViewDistance = this.getClientViewDistance();
-            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!GlobalConfiguration.get().chunkLoading.autoconfigSendDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
-            return sendViewDistance;
-        }
+        protected final TreeSet<ChunkPriorityHolder> sendQueueForTracking = createSendQueue();
+        protected final TreeSet<ChunkPriorityHolder> sendQueueForSeeing = createSendQueue();
 
-        public void setTargetSendViewDistance(final int distance) {
-            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
-                throw new IllegalArgumentException("Send view distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + " or -1, got: " + distance);
-            }
-            this.sendViewDistance = distance;
+        protected LongOpenHashSet getSentChunks(final boolean concernsTracking) {
+            return concernsTracking ? this.sentChunksForTracking : this.sentChunksForSeeing;
         }
-
-        public int getTargetNoTickViewDistance() {
-            return (this.loadViewDistance == -1 ? this.getLoadDistance() : this.loadViewDistance) - 1;
+        protected LongOpenHashSet getChunksToBeSent(final boolean concernsTracking) {
+            return concernsTracking ? this.chunksToBeSentForTracking : this.chunksToBeSentForSeeing;
         }
 
-        public void setTargetNoTickViewDistance(final int distance) {
-            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE)) {
-                throw new IllegalArgumentException("Simulation distance must be a number between " + MIN_VIEW_DISTANCE + " and " + MAX_VIEW_DISTANCE + " or -1, got: " + distance);
-            }
-            this.loadViewDistance = distance == -1 ? -1 : distance + 1;
+        protected TreeSet<ChunkPriorityHolder> getSendQueue(final boolean concernsTracking) {
+            return concernsTracking ? this.sendQueueForTracking : this.sendQueueForSeeing;
         }
 
+//        protected int sendViewDistance = -1;
+//        protected int loadViewDistance = -1;
+        public int tickViewDistance = -1;
+
+        protected long nextChunkSendTarget;
+
+//        // these view distance methods are for api
+//        public int getTargetSendViewDistance() {
+//            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+//            final int clientViewDistance = this.getClientViewDistance();
+//            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!PaperConfig.playerAutoConfigureSendViewDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+//            return sendViewDistance;
+//        }
+//
+//        public void setTargetSendViewDistance(final int distance) {
+//            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE + 1)) {
+//                throw new IllegalArgumentException("Send view distance must be a number between " + MIN_VIEW_DISTANCE + " and " + (MAX_VIEW_DISTANCE + 1) + " or -1, got: " + distance);
+//            }
+//            this.sendViewDistance = distance;
+//        }
+//
+//        public int getTargetNoTickViewDistance() {
+//            return (this.loadViewDistance == -1 ? this.getLoadDistance() : this.loadViewDistance) - 1;
+//        }
+//
+//        public void setTargetNoTickViewDistance(final int distance) {
+//            if (distance != -1 && (distance < MIN_VIEW_DISTANCE || distance > MAX_VIEW_DISTANCE)) {
+//                throw new IllegalArgumentException("Simulation distance must be a number between " + MIN_VIEW_DISTANCE + " and " + MAX_VIEW_DISTANCE + " or -1, got: " + distance);
+//            }
+//            this.loadViewDistance = distance == -1 ? -1 : distance + 1;
+//        }
+
+        // Suki end - per-player view distance
+
         public int getTargetTickViewDistance() {
-            return this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+            // Suki start - per-player load distance
+            return player.getTickingViewDistance();
+            // Suki end - per-player load distance
         }
 
         public void setTargetTickViewDistance(final int distance) {
@@ -860,33 +850,37 @@ public final class PlayerChunkLoader {
             this.tickViewDistance = distance;
         }
 
-        protected int getLoadDistance() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//        protected int getLoadDistance() {
+//            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+//
+//            return Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+//        }
 
-            return Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
-        }
+        // Suki start - per-player view distance
 
-        public boolean hasSentChunk(final int chunkX, final int chunkZ) {
-            return this.sentChunks.contains(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+        public boolean hasSentChunk(final int chunkX, final int chunkZ, final boolean concernsTracking) {
+            return this.getSentChunks(concernsTracking).contains(CoordinateUtils.getChunkKey(chunkX, chunkZ));
         }
 
-        public void sendChunk(final int chunkX, final int chunkZ, final Runnable onChunkSend) {
-            if (this.sentChunks.add(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        public void sendChunk(final int chunkX, final int chunkZ, final Runnable onChunkSend, final boolean concernsTracking) {
+            if (this.getSentChunks(concernsTracking).add(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
                 this.player.getLevel().getChunkSource().chunkMap.updateChunkTracking(this.player,
-                        new ChunkPos(chunkX, chunkZ), new MutableObject<>(), false, true); // unloaded, loaded
+                        new ChunkPos(chunkX, chunkZ), new MutableObject<>(), false, true, concernsTracking); // unloaded, loaded
                 this.player.connection.connection.execute(onChunkSend);
             } else {
                 throw new IllegalStateException();
             }
         }
 
-        public void unloadChunk(final int chunkX, final int chunkZ) {
-            if (this.sentChunks.remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
+        public void unloadChunk(final int chunkX, final int chunkZ, final boolean concernsTracking) {
+            if (this.getSentChunks(concernsTracking).remove(CoordinateUtils.getChunkKey(chunkX, chunkZ))) {
                 this.player.getLevel().getChunkSource().chunkMap.updateChunkTracking(this.player,
-                        new ChunkPos(chunkX, chunkZ), null, true, false); // unloaded, loaded
+                        new ChunkPos(chunkX, chunkZ), null, true, false, concernsTracking); // unloaded, loaded
             }
         }
 
+        // Suki end - per-player view distance
+
         protected static boolean wantChunkLoaded(final int centerX, final int centerZ, final int chunkX, final int chunkZ,
                                                  final int sendRadius) {
             // expect sendRadius to be = 1 + target viewable radius
@@ -928,7 +922,10 @@ public final class PlayerChunkLoader {
         }
 
         public void remove() {
-            this.loader.broadcastMap.remove(this.player);
+            // Suki start - per-player track and see view distance
+            this.loader.getBroadcastMap(false).remove(this.player);
+            this.loader.getBroadcastMap(true).remove(this.player);
+            // Suki end - per-player track and see view distance
             this.loader.loadMap.remove(this.player);
             this.loader.loadTicketCleanup.remove(this.player);
             this.loader.tickMap.remove(this.player);
@@ -938,13 +935,20 @@ public final class PlayerChunkLoader {
             return this.player.clientViewDistance == null ? -1 : Math.max(0, this.player.clientViewDistance.intValue());
         }
 
-        public void update() {
-            final int tickViewDistance = this.tickViewDistance == -1 ? this.loader.getTickDistance() : this.tickViewDistance;
+        // Suki start - per-player view distance
+        public void update(boolean recalculateMapsIfOnlyViewDistanceChanged) { // Only recalculate the chunk loading maps if only the view distance changed in specific scenarios (world change, tick) and not every time the player moves (in which case we will still update the chunk loading maps if the player moved to a different chunk, of course)
+            this.player.level.timings.playerChunkLoaderUpdate.startTiming(); try {
+            this.player.level.timings.playerChunkLoaderUpdateGetViewDistances.startTiming();
+            final int loadViewDistance = this.player.getLoadViewDistance();
             // load view cannot be less-than tick view + 1
-            final int loadViewDistance = Math.max(tickViewDistance + 1, this.loadViewDistance == -1 ? this.loader.getLoadDistance() : this.loadViewDistance);
+            final int tickViewDistance = this.player.getTickingViewDistance();
             // send view cannot be greater-than load view
             final int clientViewDistance = this.getClientViewDistance();
-            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!GlobalConfiguration.get().chunkLoading.autoconfigSendDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+//            final int sendViewDistance = Math.min(loadViewDistance, this.sendViewDistance == -1 ? (!GlobalConfiguration.get().chunkLoading.autoconfigSendDistance || clientViewDistance == -1 ? this.loader.getSendDistance() : clientViewDistance + 1) : this.sendViewDistance);
+            final int trackViewDistance = this.player.getTrackViewDistance();
+            final int seeViewDistance = this.player.getSeeViewDistance();
+            this.player.level.timings.playerChunkLoaderUpdateGetViewDistances.stopTiming();
+            // Suki end - per-player view distance
 
             final double posX = this.player.getX();
             final double posZ = this.player.getZ();
@@ -957,11 +961,14 @@ public final class PlayerChunkLoader {
             // make sure we're in the send queue
             this.loader.chunkSendWaitQueue.add(this);
 
+            this.player.level.timings.playerChunkLoaderUpdateDecideWhetherToRecalculate.startTiming(); try { // Suki - per-player view distance
             if (
                 // has view distance stayed the same?
-                    sendViewDistance == this.lastSendDistance
+                // Suki start - per-player view distance
+                (!recalculateMapsIfOnlyViewDistanceChanged || (trackViewDistance == this.lastTrackDistance && seeViewDistance == this.lastSeeDistance // Suki - per-player track and see view distance
                             && loadViewDistance == this.lastLoadDistance
-                            && tickViewDistance == this.lastTickDistance
+                            && tickViewDistance == this.lastTickDistance))
+                        // Suki end - per-player view distance
 
                             && (this.usingLookingPriority ? (
                                     // has our block stayed the same (this also accounts for chunk change)?
@@ -982,21 +989,26 @@ public final class PlayerChunkLoader {
                 // nothing we care about changed, so we're not re-calculating
                 return;
             }
+            } finally { this.player.level.timings.playerChunkLoaderUpdateDecideWhetherToRecalculate.stopTiming(); }  // Suki - per-player view distance
 
             final int centerChunkX = Mth.floor(posX) >> 4;
             final int centerChunkZ = Mth.floor(posZ) >> 4;
 
             final boolean needsChunkCenterUpdate = (centerChunkX != this.lastChunkX) || (centerChunkZ != this.lastChunkZ);
-            this.loader.broadcastMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, sendViewDistance);
+
+            // Suki start - per-player track and see view distance
+            this.loader.getBroadcastMap(false).addOrUpdate(this.player, centerChunkX, centerChunkZ, seeViewDistance);
+            this.loader.getBroadcastMap(true).addOrUpdate(this.player, centerChunkX, centerChunkZ, trackViewDistance);
+            // Suki end - per-player track and see view distance
             this.loader.loadMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, loadViewDistance);
             this.loader.loadTicketCleanup.addOrUpdate(this.player, centerChunkX, centerChunkZ, loadViewDistance + 1);
             this.loader.tickMap.addOrUpdate(this.player, centerChunkX, centerChunkZ, tickViewDistance);
 
-            if (sendViewDistance != this.lastSendDistance) {
+            if (seeViewDistance != this.lastSeeDistance) { // Suki - per-player track and see view distance
                 // update the view radius for client
                 // note that this should be after the map calls because the client wont expect unload calls not in its VD
                 // and it's possible we decreased VD here
-                this.player.connection.send(new ClientboundSetChunkCacheRadiusPacket(sendViewDistance));
+                this.player.connection.send(new ClientboundSetChunkCacheRadiusPacket(seeViewDistance)); // Suki - per-player track and see view distance
             }
             if (tickViewDistance != this.lastTickDistance) {
                 this.player.connection.send(new ClientboundSetSimulationDistancePacket(tickViewDistance));
@@ -1005,7 +1017,10 @@ public final class PlayerChunkLoader {
             this.lastLocX = posX;
             this.lastLocZ = posZ;
             this.lastYaw = yaw;
-            this.lastSendDistance = sendViewDistance;
+            // Suki start - per-player track and see view distance
+            this.lastTrackDistance = trackViewDistance;
+            this.lastSeeDistance = seeViewDistance;
+            // Suki start - per-player track and see view distance
             this.lastLoadDistance = loadViewDistance;
             this.lastTickDistance = tickViewDistance;
             this.usingLookingPriority = useLookPriority;
@@ -1035,76 +1050,87 @@ public final class PlayerChunkLoader {
 
             final List<ChunkPriorityHolder> loadQueue = new ArrayList<>();
 
+            // Suki start - per-player track and see view distance
+
             // clear send queue, we are re-sorting
-            this.sendQueue.clear();
+            this.getSendQueue(false).clear();
+            this.getSendQueue(true).clear();
             // clear chunk want set, vd/position might have changed
-            this.chunksToBeSent.clear();
-
-            final int searchViewDistance = Math.max(loadViewDistance, sendViewDistance);
-
-            for (int dx = -searchViewDistance; dx <= searchViewDistance; ++dx) {
-                for (int dz = -searchViewDistance; dz <= searchViewDistance; ++dz) {
-                    final int chunkX = dx + centerChunkX;
-                    final int chunkZ = dz + centerChunkZ;
-                    final int squareDistance = Math.max(Math.abs(dx), Math.abs(dz));
-                    final boolean sendChunk = squareDistance <= sendViewDistance && wantChunkLoaded(centerChunkX, centerChunkZ, chunkX, chunkZ, sendViewDistance);
-
-                    if (this.hasSentChunk(chunkX, chunkZ)) {
-                        // already sent (which means it is also loaded)
-                        if (!sendChunk) {
-                            // have sent the chunk, but don't want it anymore
-                            // unload it now
-                            this.unloadChunk(chunkX, chunkZ);
+            this.getChunksToBeSent(false).clear();
+            this.getChunksToBeSent(true).clear();
+
+            for (boolean concernsTracking : new boolean[] {false, true}) {
+
+                final int sendViewDistance = concernsTracking ? trackViewDistance : seeViewDistance;
+
+                final int searchViewDistance = Math.max(loadViewDistance, sendViewDistance);
+
+                for (int dx = -searchViewDistance; dx <= searchViewDistance; ++dx) {
+                    for (int dz = -searchViewDistance; dz <= searchViewDistance; ++dz) {
+                        final int chunkX = dx + centerChunkX;
+                        final int chunkZ = dz + centerChunkZ;
+                        final int squareDistance = Math.max(Math.abs(dx), Math.abs(dz));
+                        final boolean sendChunk = squareDistance <= sendViewDistance && wantChunkLoaded(centerChunkX, centerChunkZ, chunkX, chunkZ, sendViewDistance);
+
+                        if (this.hasSentChunk(chunkX, chunkZ, concernsTracking)) {
+                            // already sent (which means it is also loaded)
+                            if (!sendChunk) {
+                                // have sent the chunk, but don't want it anymore
+                                // unload it now
+                                this.unloadChunk(chunkX, chunkZ, concernsTracking);
+                            }
+                            continue;
                         }
-                        continue;
-                    }
 
-                    final boolean loadChunk = squareDistance <= loadViewDistance;
+                        final boolean loadChunk = squareDistance <= loadViewDistance;
 
-                    final boolean prioritised = useLookPriority && triangleIntersects(
+                        final boolean prioritised = useLookPriority && triangleIntersects(
                             // prioritisation triangle
                             p1x, p1z, p2x, p2z, p3x, p3z,
 
                             // center of chunk
-                            (double)((chunkX << 4) | 8), (double)((chunkZ << 4) | 8)
-                    );
+                            (double) ((chunkX << 4) | 8), (double) ((chunkZ << 4) | 8)
+                        );
 
-                    final int manhattanDistance = Math.abs(dx) + Math.abs(dz);
+                        final int manhattanDistance = Math.abs(dx) + Math.abs(dz);
 
-                    final double priority;
+                        final double priority;
 
-                    if (squareDistance <= GlobalConfiguration.get().chunkLoading.minLoadRadius) {
-                        // priority should be negative, and we also want to order it from center outwards
-                        // so we want (0,0) to be the smallest, and (minLoadedRadius,minLoadedRadius) to be the greatest
-                        priority = -((2 * GlobalConfiguration.get().chunkLoading.minLoadRadius + 1) - manhattanDistance);
-                    } else {
-                        if (prioritised) {
-                            // we don't prioritise these chunks above others because we also want to make sure some chunks
-                            // will be loaded if the player changes direction
-                            priority = (double)manhattanDistance / 6.0;
+                        if (squareDistance <= GlobalConfiguration.get().chunkLoading.minLoadRadius) {
+                            // priority should be negative, and we also want to order it from center outwards
+                            // so we want (0,0) to be the smallest, and (minLoadedRadius,minLoadedRadius) to be the greatest
+                            priority = -((2 * GlobalConfiguration.get().chunkLoading.minLoadRadius + 1) - manhattanDistance);
                         } else {
-                            priority = (double)manhattanDistance;
+                            if (prioritised) {
+                                // we don't prioritise these chunks above others because we also want to make sure some chunks
+                                // will be loaded if the player changes direction
+                                priority = (double) manhattanDistance / 6.0;
+                            } else {
+                                priority = (double) manhattanDistance;
+                            }
                         }
-                    }
 
-                    final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, priority);
+                        final ChunkPriorityHolder holder = new ChunkPriorityHolder(chunkX, chunkZ, manhattanDistance, priority);
 
-                    if (!this.loader.isChunkPlayerLoaded(chunkX, chunkZ)) {
-                        if (loadChunk) {
-                            loadQueue.add(holder);
+                        if (!this.loader.isChunkPlayerLoaded(chunkX, chunkZ)) {
+                            if (loadChunk) {
+                                loadQueue.add(holder);
+                                if (sendChunk) {
+                                    this.getChunksToBeSent(concernsTracking).add(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+                                }
+                            }
+                        } else {
+                            // loaded but not sent: so queue it!
                             if (sendChunk) {
-                                this.chunksToBeSent.add(CoordinateUtils.getChunkKey(chunkX, chunkZ));
+                                this.getSendQueue(concernsTracking).add(holder);
                             }
                         }
-                    } else {
-                        // loaded but not sent: so queue it!
-                        if (sendChunk) {
-                            this.sendQueue.add(holder);
-                        }
                     }
                 }
             }
 
+            // Suki end - per-player track and see view distance
+
             loadQueue.sort((final ChunkPriorityHolder p1, final ChunkPriorityHolder p2) -> {
                 return Double.compare(p1.priority, p2.priority);
             });
@@ -1123,6 +1149,9 @@ public final class PlayerChunkLoader {
             if (needsChunkCenterUpdate) {
                 this.player.connection.send(new ClientboundSetChunkCacheCenterPacket(centerChunkX, centerChunkZ));
             }
+
+            } finally { this.player.level.timings.playerChunkLoaderUpdate.stopTiming(); }  // Suki - per-player view distance]
+
         }
     }
 }
diff --git a/src/main/java/io/papermc/paper/chunk/system/ChunkSystem.java b/src/main/java/io/papermc/paper/chunk/system/ChunkSystem.java
index 0e45a340ae534caf676b7f9d0adcbcee5829925e..e4fc709d0a35342398a1f41cbe55a8dd25762ef0 100644
--- a/src/main/java/io/papermc/paper/chunk/system/ChunkSystem.java
+++ b/src/main/java/io/papermc/paper/chunk/system/ChunkSystem.java
@@ -128,14 +128,6 @@ public final class ChunkSystem {
         return level.chunkSource.chunkMap.getUnloadingChunkHolder(chunkX, chunkZ);
     }
 
-    public static int getSendViewDistance(final ServerPlayer player) {
-        return io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player);
-    }
-
-    public static int getLoadViewDistance(final ServerPlayer player) {
-        return io.papermc.paper.chunk.PlayerChunkLoader.getLoadViewDistance(player);
-    }
-
     public static int getTickViewDistance(final ServerPlayer player) {
         return io.papermc.paper.chunk.PlayerChunkLoader.getTickViewDistance(player);
     }
diff --git a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
index 4532f3a0d74feae0a1249b53e1bfbc18a8808b32..43ebbd97071c4e2830c3db3801e99e17091f2d55 100644
--- a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
@@ -31,6 +31,7 @@ import net.minecraft.commands.arguments.NbtPathArgument;
 import net.minecraft.core.Holder;
 import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.world.Difficulty;
 import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.MobCategory;
diff --git a/src/main/java/io/papermc/paper/util/MCUtil.java b/src/main/java/io/papermc/paper/util/MCUtil.java
index fe8d2fa5fdb116762b644b08020fee23e517e57c..012cc6c59bcc1e1bc96c816f30fe718cd301a005 100644
--- a/src/main/java/io/papermc/paper/util/MCUtil.java
+++ b/src/main/java/io/papermc/paper/util/MCUtil.java
@@ -607,7 +607,12 @@ public final class MCUtil {
 
             worldData.addProperty("is-loaded", loadedWorlds.contains(bukkitWorld));
             worldData.addProperty("name", world.getWorld().getName());
-            worldData.addProperty("view-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance()); // Paper - replace chunk loader system
+            // Suki start - per-player view distance
+            worldData.addProperty("view-distance", world.getChunkSource().chunkMap.getVanillaWorldViewDistance()); // Paper - replace chunk loader system
+            worldData.addProperty("max-track-view-distance", world.sukiConfig().viewDistance.track.getMax());
+            worldData.addProperty("max-see-view-distance", world.sukiConfig().viewDistance.see.getMax());
+            worldData.addProperty("max-load-view-distance", world.sukiConfig().viewDistance.load.getMax());
+            // Suki end - per-player view distance
             worldData.addProperty("tick-view-distance", world.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance()); // Paper - replace chunk loader system
             worldData.addProperty("keep-spawn-loaded", world.keepSpawnInMemory);
             worldData.addProperty("keep-spawn-loaded-range", world.paperConfig().spawn.keepSpawnLoadedRange * 16);
diff --git a/src/main/java/net/minecraft/server/level/ChunkHolder.java b/src/main/java/net/minecraft/server/level/ChunkHolder.java
index 153b4489770d646ba5d6cd4a07b2d23bfee3dbaa..76a33df4e76bdf38150b9ff7a93cb3f535eed5c1 100644
--- a/src/main/java/net/minecraft/server/level/ChunkHolder.java
+++ b/src/main/java/net/minecraft/server/level/ChunkHolder.java
@@ -355,7 +355,7 @@ public class ChunkHolder {
         // Paper start - per player view distance
         // there can be potential desync with player's last mapped section and the view distance map, so use the
         // view distance map here.
-        com.destroystokyo.paper.util.misc.PlayerAreaMap viewDistanceMap = this.chunkMap.playerChunkManager.broadcastMap; // Paper - replace old player chunk manager
+        com.destroystokyo.paper.util.misc.PlayerAreaMap viewDistanceMap = this.chunkMap.playerChunkManager.broadcastMapForTracking; // Paper - replace old player chunk manager // Suki - per-player track and see view distance
         com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = viewDistanceMap.getObjectsInRange(this.pos);
         if (players == null) {
             return;
@@ -366,7 +366,7 @@ public class ChunkHolder {
             if (!(backingSet[i] instanceof ServerPlayer player)) {
                 continue;
             }
-            if (!this.chunkMap.playerChunkManager.isChunkSent(player, this.pos.x, this.pos.z, onlyOnWatchDistanceEdge)) {
+            if (!this.chunkMap.playerChunkManager.isChunkSent(player, this.pos.x, this.pos.z, onlyOnWatchDistanceEdge, true)) { // Suki - per-player track and see view distance
                 continue;
             }
             player.connection.send(packet);
@@ -416,7 +416,8 @@ public class ChunkHolder {
 
     public interface PlayerProvider {
 
-        List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge);
+        List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge, boolean concernsTracking); // Suki - per-player track and see view distance
+
     }
 
     private static final class ChunkSaveDebug {
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 0a39aaf5bc54e1fb7fb4bada2a15fea9b73af731..7e14fd470fdf99b245b78e0829128f77079857fd 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -154,7 +154,10 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     private final Long2ByteMap chunkTypeCache;
     private final Long2LongMap chunkSaveCooldowns;
     private final Queue<Runnable> unloadQueue;
-    int viewDistance;
+    // Martijn start- per-player view distance
+    // This value is the intended world send view distance + 1
+    private int vanillaWorldViewDistancePlusOne;
+    // Suki end - per-player view distance
     public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerMobDistanceMap; // Paper
     public final ReferenceOpenHashSet<ChunkHolder> needsChangeBroadcasting = new ReferenceOpenHashSet<>();
 
@@ -214,7 +217,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
             int trackRange = this.entityTrackerTrackRanges[i];
 
-            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, io.papermc.paper.chunk.system.ChunkSystem.getSendViewDistance(player)));
+            trackMap.add(player, chunkX, chunkZ, Math.min(trackRange, player.getTrackViewDistance())); // Suki - per-player track view distance
         }
         // Paper end - use distance map to optimise entity tracker
         this.playerGeneralAreaMap.add(player, chunkX, chunkZ, GENERAL_AREA_MAP_SQUARE_RADIUS); // Paper - optimise checkDespawn
@@ -240,11 +243,11 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         // Paper end - use distance map to optimise tracker
     }
 
-    void updateMaps(ServerPlayer player) {
+    void updateMaps(ServerPlayer player, boolean recalculateChunkLoadingMapsIfOnlyViewDistanceChanged) { // Suki - per-player view distance
         int chunkX = MCUtil.getChunkCoordinate(player.getX());
         int chunkZ = MCUtil.getChunkCoordinate(player.getZ());
         // Note: players need to be explicitly added to distance maps before they can be updated
-        this.playerChunkManager.updatePlayer(player); // Paper - replace chunk loader
+        this.playerChunkManager.updatePlayer(player, recalculateChunkLoadingMapsIfOnlyViewDistanceChanged); // Paper - replace chunk loader // Suki - per-player view distance
         this.playerChunkTickRangeMap.update(player, chunkX, chunkZ, DistanceManager.MOB_SPAWN_RANGE); // Paper - optimise ChunkMap#anyPlayerCloseEnoughForSpawning
         // Paper start - per player mob spawning
         if (this.playerMobDistanceMap != null) {
@@ -256,7 +259,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             com.destroystokyo.paper.util.misc.PlayerAreaMap trackMap = this.playerEntityTrackerTrackMaps[i];
             int trackRange = this.entityTrackerTrackRanges[i];
 
-            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, io.papermc.paper.chunk.system.ChunkSystem.getSendViewDistance(player)));
+            trackMap.update(player, chunkX, chunkZ, Math.min(trackRange, player.getTrackViewDistance())); // Suki - per-player track view distance
+
         }
         // Paper end - use distance map to optimise entity tracker
         this.playerGeneralAreaMap.update(player, chunkX, chunkZ, GENERAL_AREA_MAP_SQUARE_RADIUS); // Paper - optimise checkDespawn
@@ -293,7 +297,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     }
     // Paper end
 
-    public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int viewDistance, boolean dsync) {
+    public ChunkMap(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor executor, BlockableEventLoop<Runnable> mainThreadExecutor, LightChunkGetter chunkProvider, ChunkGenerator chunkGenerator, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory, int vanillaWorldViewDistance, boolean dsync) { // Suki - per-player view distance
         super(session.getDimensionPath(world.dimension()).resolve("region"), dataFixer, dsync);
         // Paper - rewrite chunk system
         this.tickingGenerated = new AtomicInteger();
@@ -340,7 +344,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.distanceManager = new ChunkMap.ChunkDistanceManager(executor, mainThreadExecutor);
         this.overworldDataStorage = persistentStateManagerFactory;
         this.poiManager = new PoiManager(path.resolve("poi"), dataFixer, dsync, iregistrycustom, world);
-        this.setViewDistance(viewDistance);
+        this.setVanillaWorldViewDistance(vanillaWorldViewDistance); // Suki - per-player view distance
         // Paper start
         this.dataRegionManager = new io.papermc.paper.chunk.SingleThreadChunkRegionManager(this.level, 2, (1.0 / 3.0), 1, 6, "Data", DataRegionData::new, DataRegionSectionData::new);
         this.regionManagers.add(this.dataRegionManager);
@@ -558,13 +562,15 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
     }
 
+    // Suki start - per-player view distance
     // Paper start
-    public final int getEffectiveViewDistance() {
+    public final int getVanillaWorldViewDistance() {
         // TODO this needs to be checked on update
         // Mojang currently sets it to +1 of the configured view distance. So subtract one to get the one we really want.
-        return this.viewDistance - 1;
+        return this.vanillaWorldViewDistancePlusOne - 1;
     }
     // Paper end
+    // Suki end - per-player view distance
 
     private CompletableFuture<Either<List<ChunkAccess>, ChunkHolder.ChunkLoadingFailure>> getChunkRangeFuture(ChunkPos centerChunk, int margin, IntFunction<ChunkStatus> distanceToStatus) {
         throw new UnsupportedOperationException(); // Paper - rewrite chunk system
@@ -813,19 +819,23 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.playerChunkManager.setTickDistance(distance);
     }
     // Paper end - replace player loader system
-    public void setViewDistance(int watchDistance) {
-        int j = Mth.clamp(watchDistance + 1, 3, 33);
 
-        if (j != this.viewDistance) {
-            int k = this.viewDistance;
+    // Suki start - per-player view distance
+    public void setVanillaWorldViewDistance(int vanillaWorldViewDistance) {
+        int newVanillaWorldViewDistancePlusOne = Mth.clamp(vanillaWorldViewDistance + 1, (int) 3, (int) 33);
+
+        if (newVanillaWorldViewDistancePlusOne != this.vanillaWorldViewDistancePlusOne) {
+            int k = this.vanillaWorldViewDistancePlusOne;
 
-            this.viewDistance = j;
-            this.playerChunkManager.setLoadDistance(this.viewDistance); // Paper - replace player loader system
+            this.vanillaWorldViewDistancePlusOne = newVanillaWorldViewDistancePlusOne;
+            // No longer needed since PlayerChunkLoader.update() will pull the most current load view distance when it executes
+//            this.playerChunkManager.setLoadDistance(Mth.clamp(this.vanillaWorldViewDistancePlusOne, 2, 32)); // Paper - replace player loader system
         }
 
     }
+    // Suki end - per-player view distance
 
-    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance) { // Paper - public // Paper - Anti-Xray - Bypass
+    public void updateChunkTracking(ServerPlayer player, ChunkPos pos, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> packet, boolean oldWithinViewDistance, boolean newWithinViewDistance, boolean concernsTracking) { // Paper - Anti-Xray - Bypass // Paper - public // Suki - per-player track and see view distance
         if (player.level == this.level) {
             if (newWithinViewDistance && !oldWithinViewDistance) {
                 ChunkHolder playerchunk = this.getVisibleChunkIfPresent(pos.toLong());
@@ -834,7 +844,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                     LevelChunk chunk = playerchunk.getSendingChunk(); // Paper - replace chunk loader system
 
                     if (chunk != null) {
-                        this.playerLoadedChunk(player, packet, chunk);
+                        this.playerLoadedChunk(player, packet, chunk, concernsTracking); // Suki - per-player track and see view distance
                     }
 
                     DebugPackets.sendPoiPacketsForChunk(this.level, pos);
@@ -842,7 +852,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
 
             if (!newWithinViewDistance && oldWithinViewDistance) {
-                player.untrackChunk(pos);
+                player.untrackChunk(pos, concernsTracking); // Suki - per-player track and see view distance
             }
 
         }
@@ -1104,6 +1114,8 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public void move(ServerPlayer player) {
         // Paper - delay this logic for the entity tracker tick, no need to duplicate it
 
+        this.level.timings.chunkMapPlayerMove.startTiming(); // Suki - per-player view distance
+
         int i = SectionPos.blockToSectionCoord(player.getBlockX());
         int j = SectionPos.blockToSectionCoord(player.getBlockZ());
         SectionPos sectionposition = player.getLastSectionPos();
@@ -1144,17 +1156,21 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
 
         // Paper - replaced by PlayerChunkLoader
 
-        this.updateMaps(player); // Paper - distance maps
-        this.playerChunkManager.updatePlayer(player); // Paper - respond to movement immediately
+        // Suki start - per-player view distance
+        this.updateMaps(player, false); // Paper - distance maps
+        this.playerChunkManager.updatePlayer(player, false); // Paper - respond to movement immediately
+        // Suki end - per-player view distance
+
+        this.level.timings.chunkMapPlayerMove.stopTiming(); // Suki - per-player view distance
 
     }
 
     @Override
-    public List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge) {
+    public List<ServerPlayer> getPlayers(ChunkPos chunkPos, boolean onlyOnWatchDistanceEdge, boolean concernsTracking) { // Suki - per-player track and see view distance
         // Paper start - per player view distance
         // there can be potential desync with player's last mapped section and the view distance map, so use the
         // view distance map here.
-        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = this.playerChunkManager.broadcastMap.getObjectsInRange(chunkPos);
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> players = this.playerChunkManager.getBroadcastMap(concernsTracking).getObjectsInRange(chunkPos); // Suki - per-player track and see view distance
         if (players == null) {
             return java.util.Collections.emptyList();
         }
@@ -1270,6 +1286,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end - optimised tracker
 
     protected void tick() {
+
+        // Suki start - temporary debug message containing the number of loaded chunks
+        if (this.level.sukiConfig().viewDistance.load.printLoadedChunksInterval > 0 && Math.random() < 1.0 / this.level.sukiConfig().viewDistance.load.printLoadedChunksInterval) {
+            org.bukkit.Bukkit.getLogger().info("Number of loaded chunks in " + this.level.getWorld().getName() + ": " + this.level.getWorld().getLoadedChunks().length);
+        }
+        // Suki end - temporary debug message containing the number of loaded chunks
+
         // Paper start - optimized tracker
         if (true) {
             this.processTrackQueue();
@@ -1354,7 +1377,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 chunk = this.level.getChunk(chunkcoordintpair.x, chunkcoordintpair.z);
             }
 
-            Iterator iterator1 = this.getPlayers(chunkcoordintpair, false).iterator();
+            Iterator iterator1 = this.getPlayers(chunkcoordintpair, false, false).iterator(); // Suki - per-player track and see view distance - send biome updates within see distance
 
             while (iterator1.hasNext()) {
                 ServerPlayer entityplayer = (ServerPlayer) iterator1.next();
@@ -1411,7 +1434,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end - Fix MC-162253
 
     // Paper start - Anti-Xray - Bypass
-    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk) {
+    private void playerLoadedChunk(ServerPlayer player, MutableObject<java.util.Map<Object, ClientboundLevelChunkWithLightPacket>> cachedDataPackets, LevelChunk chunk, boolean concernsTracking) { // Suki - per-player track and see view distance
         if (cachedDataPackets.getValue() == null) {
             cachedDataPackets.setValue(new java.util.HashMap<>());
         }
@@ -1419,7 +1442,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
         player.trackChunk(chunk.getPos(), (Packet) cachedDataPackets.getValue().computeIfAbsent(shouldModify, (s) -> {
             // Paper start - Fix MC-162253
-            final int viewDistance = getEffectiveViewDistance();
+            final int viewDistance = getVanillaWorldViewDistance(); // Suki - per-player view distance
             final int playerChunkX = player.getBlockX() >> 4;
             final int playerChunkZ = player.getBlockZ() >> 4;
 
@@ -1458,7 +1481,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             }
             // Paper end - Fix MC-162253
             return new ClientboundLevelChunkWithLightPacket(chunk, this.lightEngine, (BitSet) null, (BitSet) null, true, (Boolean) s);
-        }));
+        }), concernsTracking); // Suki - per-player track and see view distance
         // Paper end
         DebugPackets.sendPoiPacketsForChunk(this.level, chunk.getPos());
         // Paper - no longer needed - this was used to account for clients bugging out since they needed a chunk to store entities, but they no longer need a chunk
@@ -1606,7 +1629,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 double vec3d_dx = player.getX() - this.entity.getX();
                 double vec3d_dz = player.getZ() - this.entity.getZ();
                 // Paper end - remove allocation of Vec3D here
-                double d0 = (double) Math.min(this.getEffectiveRange(), io.papermc.paper.chunk.PlayerChunkLoader.getSendViewDistance(player) * 16); // Paper - per player view distance
+                double d0 = (double) Math.min(this.getEffectiveRange(), player.getTrackViewDistance() * 16); // Paper - per player view distance // Suki - per-player track view distance
                 double d1 = vec3d_dx * vec3d_dx + vec3d_dz * vec3d_dz; // Paper
                 double d2 = d0 * d0;
                 boolean flag = d1 <= d2 && this.entity.broadcastToPlayer(player);
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index 52cba8f68d274cce106304aef1249a95474d3238..12f07471c03a12995086085a0162472c33e0ba64 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -183,9 +183,12 @@ public abstract class DistanceManager {
         return this.getChunkHolderManager().getTicketDebugString(pos); // Paper - rewrite chunk system
     }
 
-    protected void updatePlayerTickets(int viewDistance) {
-        this.chunkMap.playerChunkManager.setTargetNoTickViewDistance(viewDistance); // Paper - route to player chunk manager
-    }
+    // Suki start - per-player load view distance
+    // No longer needed since PlayerChunkLoader.update() will pull the most current load view distance when it executes
+//    protected void updatePlayerTickets(int viewDistance) {
+//        this.chunkMap.playerChunkManager.setTargetNoTickViewDistance(viewDistance); // Paper - route to player chunk manager
+//    }
+    // Suki end - per-player load view distance
 
     // Paper start
     public int getSimulationDistance() {
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index df4db98618c6c9261b4ec8e2987c4ed26af4bd4b..ff6a400baa23e2f77bca111d19aa3727d22d2320 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -664,7 +664,7 @@ public class ServerChunkCache extends ChunkSource {
                     continue;
                 }
 
-                int viewDistance = this.chunkMap.getEffectiveViewDistance();
+                int viewDistance = this.chunkMap.getVanillaWorldViewDistance(); // Suki - per-player view distance
 
                 // copied and modified from isOutisdeRange
                 int chunkRange = level.spigotConfig.mobSpawnRange;
@@ -928,9 +928,11 @@ public class ServerChunkCache extends ChunkSource {
         this.chunkMap.broadcast(entity, packet);
     }
 
-    public void setViewDistance(int watchDistance) {
-        this.chunkMap.setViewDistance(watchDistance);
+    // Suki start - per-player view distance
+    public void setVanillaWorldViewDistance(int vanillaWorldViewDistance) {
+        this.chunkMap.setVanillaWorldViewDistance(vanillaWorldViewDistance);
     }
+    // Suki end - per-player view distance
 
     public void setSimulationDistance(int simulationDistance) {
         this.distanceManager.updateSimulationDistance(simulationDistance);
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 985ae9a73a2301e1f369c1dfaccb9c4fb0587075..7a0316146dffd696ec75a4c21beb41e0afbda30d 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -1,5 +1,6 @@
 package net.minecraft.server.level;
 
+import co.aikar.timings.Timing;
 import com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent;
 import com.google.common.collect.Lists;
 import com.google.common.net.InetAddresses;
@@ -10,6 +11,7 @@ import com.mojang.serialization.DataResult;
 import com.mojang.serialization.Dynamic;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
+
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
@@ -18,6 +20,8 @@ import java.util.Optional;
 import java.util.OptionalInt;
 import java.util.Set;
 import javax.annotation.Nullable;
+
+import io.papermc.paper.chunk.PlayerChunkLoader;
 import net.minecraft.BlockUtil;
 import net.minecraft.ChatFormatting;
 import net.minecraft.CrashReport;
@@ -182,11 +186,294 @@ import org.bukkit.event.player.PlayerPortalEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.inventory.MainHand;
+import org.sucraft.suki.configuration.SukiGlobalConfiguration;
+import org.jetbrains.annotations.NotNull;
 // CraftBukkit end
 
 public class ServerPlayer extends Player {
 
     private static final Logger LOGGER = LogUtils.getLogger();
+
+    // Suki start - per-player view distance
+
+    private static int[] maxViewDistanceDueToTotalViewedChunks = {32, 32};
+
+    /**
+     * Does not change any state
+     * Is called only from ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type)
+     */
+    private static int computeMaxViewDistanceDueToTotalViewedChunks(int type) {
+        int maxTotalChunks = ((type == 0) ? SukiGlobalConfiguration.get().viewDistance.track : SukiGlobalConfiguration.get().viewDistance.see).getMaxTotalChunks();
+        if (maxTotalChunks == -1) return -1;
+        int candidateViewDistance = maxViewDistanceDueToTotalViewedChunks[type];
+        int[] playerViewDistances = new int[MinecraftServer.getServer().getPlayerCount()];
+        int playerI = 0;
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().players) {
+            playerViewDistances[playerI] = player.getViewDistance(type);
+            playerI++;
+        }
+        for (boolean increase : new boolean[] {false, true}) {
+            int chunks = 0;
+            for (int playerViewDistance : playerViewDistances) {
+                // We assume the worst: that if the player's view distance is equal to the current limit, that it will definitely grow to the new limit
+                int playerViewDistanceUnderCandidateAssumption = playerViewDistance >= ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] ? candidateViewDistance : Math.min(candidateViewDistance, playerViewDistance);
+                int playerViewDimensionUnderCandidateAssumption = playerViewDistanceUnderCandidateAssumption * 2 + 1;
+                chunks += playerViewDimensionUnderCandidateAssumption * playerViewDimensionUnderCandidateAssumption;
+            }
+            if (candidateViewDistance > 2 && (chunks > maxTotalChunks || candidateViewDistance > 32)) {
+                candidateViewDistance--;
+                if (increase) {
+                    continue;
+                }
+            } else {
+                candidateViewDistance++;
+                if (!increase) {
+                    continue;
+                }
+            }
+        }
+        return candidateViewDistance;
+    }
+
+    /**
+     * Is called only from ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type)
+     */
+    private static void processMaxViewDistanceDueToTotalViewedChunksChange(int oldMaxViewDistanceDueToTotalViewedChunks, int type) {
+        if (oldMaxViewDistanceDueToTotalViewedChunks == ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type]) return;
+        for (ServerPlayer player : MinecraftServer.getServer().getPlayerList().players) {
+            player.viewDistanceMayHaveChanged(type);
+        }
+    }
+
+    public static void maxTrackViewDistanceDueToTotalTrackedChunksMayHaveChanged() {
+        ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(0);
+    }
+
+    public static void maxSeeViewDistanceDueToTotalSeenChunksMayHaveChanged() {
+        ServerPlayer.maxViewDistanceDueToTotalViewedChunksMayHaveChanged(1);
+    }
+
+    /**
+     * Is called only from ServerPlayer.processViewDistanceChange(type)
+     */
+    private static void maxViewDistanceDueToTotalViewedChunksMayHaveChanged(int type) {
+        int oldMaxViewDistanceDueToTotalViewedChunks = ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type];
+        ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] = ServerPlayer.computeMaxViewDistanceDueToTotalViewedChunks(type);
+        ServerPlayer.processMaxViewDistanceDueToTotalViewedChunksChange(oldMaxViewDistanceDueToTotalViewedChunks, type);
+    }
+
+    private final int getWorldSeeViewDistance() { return this.getLevel().getChunkSource().chunkMap.getVanillaWorldViewDistance() - 1; } // Paper - placeholder
+
+    private final int getWorldTrackViewDistance() {
+        return this.getWorldSeeViewDistance();
+    }
+
+    private final int getWorldLoadViewDistance() {
+        return this.getWorldSeeViewDistance() + 1;
+    }
+
+    private final int getWorldViewDistance(int type) {
+        switch (type) {
+            case 0: return this.getWorldTrackViewDistance();
+            case 1: return this.getWorldSeeViewDistance();
+            case 2: return this.getWorldLoadViewDistance();
+        }
+        throw new IllegalArgumentException();
+    }
+
+    private @Nullable Integer @NotNull [] viewDistances = {null, null, null};
+
+    public final int getTrackViewDistance() {
+        return this.getViewDistance(0);
+    }
+
+    public final int getSeeViewDistance() {
+        return this.getViewDistance(1);
+    }
+
+    public final int getLoadViewDistance() {
+        return this.getViewDistance(2);
+    }
+
+    public final int getTickingViewDistance() {
+        int loadViewDistanceMinusOne = this.getLoadViewDistance() - 1;
+        ServerLevel level = this.getLevel();
+        if (level != null) {
+            PlayerChunkLoader playerChunkLoader = level.getChunkSource().chunkMap.playerChunkManager;
+            PlayerChunkLoader.PlayerLoaderData data = playerChunkLoader.getData(this);
+            if (data != null && data.tickViewDistance != -1) {
+                return Math.min(loadViewDistanceMinusOne, data.tickViewDistance);
+            }
+            return Math.min(loadViewDistanceMinusOne, playerChunkLoader.getTickDistance());
+        }
+        return loadViewDistanceMinusOne;
+    }
+
+    private final int getViewDistance(int type) {
+        if (this.viewDistances[type] == null) {
+            this.viewDistanceMayHaveChanged(type);
+        }
+        return this.viewDistances[type];
+    }
+
+    public final void trackViewDistanceMayHaveChanged() {
+        this.viewDistanceMayHaveChanged(0);
+    }
+
+    public final void seeViewDistanceMayHaveChanged() {
+        this.viewDistanceMayHaveChanged(1);
+    }
+
+    public final void loadViewDistanceMayHaveChanged() {
+        this.viewDistanceMayHaveChanged(2);
+    }
+
+    /**
+     * Does not change any state
+     * Is called only from ServerPlayer.viewDistanceMayHaveChanged(type)
+     */
+    private final int computeViewDistance(int type) {
+        switch (type) {
+            case 0: {
+                this.level.timings.computeTrackViewDistance.startTiming();
+
+                // Limit by world view distance
+                int trackViewDistance = this.getWorldTrackViewDistance();
+                // Limit by see view distance
+                trackViewDistance = Math.min(trackViewDistance, this.getSeeViewDistance());
+                if (this.getLevel().sukiConfig().viewDistance.track.getPerPlayer()) {
+                    // Limit by world max track view distance
+                    int levelMaxTrackViewDistance = this.getLevel().sukiConfig().viewDistance.track.getMax();
+                    if (levelMaxTrackViewDistance != -1) {
+                        trackViewDistance = Math.min(trackViewDistance, levelMaxTrackViewDistance);
+                    }
+                    // Limit by client view distance
+                    if (this.getLevel().sukiConfig().viewDistance.track.getLimitByClientViewDistance()) {
+                        if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                            trackViewDistance = Math.min(trackViewDistance, this.clientViewDistance + 1);
+                        }
+                    }
+                }
+                // Limit by max total tracked chunks
+                if (ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] != -1) {
+                    trackViewDistance = Math.min(trackViewDistance, ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type]);
+                }
+                // Clamp to possible values
+                trackViewDistance = Mth.clamp(trackViewDistance, 2, 32);
+
+                this.level.timings.computeTrackViewDistance.stopTiming();
+
+                return trackViewDistance;
+            }
+            case 1: {
+                this.level.timings.computeSeeViewDistance.startTiming();
+
+                // Limit by world view distance
+                int seeViewDistance = this.getWorldSeeViewDistance();
+                if (this.getLevel().sukiConfig().viewDistance.see.getPerPlayer()) {
+                    // Limit by world max see view distance
+                    int levelMaxSeeViewDistance = this.getLevel().sukiConfig().viewDistance.see.getMax();
+                    if (levelMaxSeeViewDistance != -1) {
+                        seeViewDistance = Math.min(seeViewDistance, levelMaxSeeViewDistance);
+                    }
+                    // Limit by client view distance
+                    if (this.getLevel().sukiConfig().viewDistance.see.getLimitByClientViewDistance()) {
+                        if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                            seeViewDistance = Math.min(seeViewDistance, this.clientViewDistance + 1);
+                        }
+                    }
+                }
+                // Limit by max total seen chunks
+                if (ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type] != -1) {
+                    seeViewDistance = Math.min(seeViewDistance, ServerPlayer.maxViewDistanceDueToTotalViewedChunks[type]);
+                }
+                // Clamp to possible values
+                seeViewDistance = Mth.clamp(seeViewDistance, 2, 32);
+
+                this.level.timings.computeSeeViewDistance.stopTiming();
+
+                return seeViewDistance;
+            }
+            case 2: {
+                this.level.timings.computeLoadViewDistance.startTiming();
+
+                // Limit by world view distance
+                int loadViewDistance = this.getWorldLoadViewDistance();
+                if (this.getLevel().sukiConfig().viewDistance.load.getPerPlayer()) {
+                    // Limit by world max load view distance
+                    int levelMaxLoadViewDistance = this.getLevel().sukiConfig().viewDistance.load.getMax();
+                    if (levelMaxLoadViewDistance != -1) {
+                        loadViewDistance = Math.min(loadViewDistance, levelMaxLoadViewDistance);
+                    }
+                    // Limit by see view distance
+                    if (this.getLevel().sukiConfig().viewDistance.load.getLimitBySeeViewDistance()) {
+                        loadViewDistance = Math.min(loadViewDistance, this.getSeeViewDistance() + 1);
+                    }
+                    // Limit by client view distance
+                    if (this.getLevel().sukiConfig().viewDistance.load.getLimitByClientViewDistance()) {
+                        if (this.clientViewDistance != null && this.clientViewDistance >= 1) {
+                            loadViewDistance = Math.min(loadViewDistance, this.clientViewDistance + 2);
+                        }
+                    }
+                }
+                // Clamp to possible values
+                loadViewDistance = Mth.clamp(loadViewDistance, 3, 33);
+
+                this.level.timings.computeLoadViewDistance.stopTiming();
+
+                return loadViewDistance;
+            }
+        }
+        throw new IllegalArgumentException();
+    }
+
+    /**
+     * Is called only from ServerPlayer.viewDistanceMayHaveChanged(type)
+     */
+    private final void processViewDistanceChange(@Nullable Integer oldViewDistance, int type) {
+
+        int newViewDistance = this.viewDistances[type];
+        if (oldViewDistance != null && oldViewDistance == newViewDistance) return;
+
+        switch (type) {
+            case 0: {
+                this.level.timings.processTrackViewDistanceChange.startTiming();
+                // Update track view distance of other players
+                maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type);
+                this.level.timings.processTrackViewDistanceChange.stopTiming();
+                break;
+            }
+            case 1: {
+                this.level.timings.processSeeViewDistanceChange.startTiming();
+                // Update track view distance
+                this.trackViewDistanceMayHaveChanged();
+                // Update load view distance
+                this.loadViewDistanceMayHaveChanged();
+                // Update see view distance of other players
+                maxViewDistanceDueToTotalViewedChunksMayHaveChanged(type);
+                this.level.timings.processSeeViewDistanceChange.stopTiming();
+                break;
+            }
+        }
+
+    }
+
+    private final void viewDistanceMayHaveChanged(int type) {
+        Timing timing = switch (type) {
+            case 0 -> this.level.timings.trackViewDistanceMayHaveChanged;
+            case 1 -> this.level.timings.seeViewDistanceMayHaveChanged;
+            case 2 -> this.level.timings.loadViewDistanceMayHaveChanged;
+            default -> null;
+        };
+        timing.startTiming();
+        Integer oldViewDistance = this.viewDistances[type];
+        this.viewDistances[type] = this.computeViewDistance(type);
+        this.processViewDistanceChange(oldViewDistance, type);
+        timing.stopTiming();
+    }
+
+    // Suki end - per-player view distance
+
     public long lastSave = MinecraftServer.currentTick; // Paper
     private static final int NEUTRAL_MOB_DEATH_NOTIFICATION_RADII_XZ = 32;
     private static final int NEUTRAL_MOB_DEATH_NOTIFICATION_RADII_Y = 10;
@@ -1993,6 +2280,11 @@ public class ServerPlayer extends Player {
         this.connection.connection.channel.attr(PaperAdventure.LOCALE_ATTRIBUTE).set(this.adventure$locale);
         // Paper end
         this.clientViewDistance = packet.getAcceptableViewDistance(); // Suki - dev import deobfuscation fixes // Suki - allow invalid client view distance
+        // Suki start - per-player view distance
+        this.trackViewDistanceMayHaveChanged();
+        this.seeViewDistanceMayHaveChanged();
+        this.loadViewDistanceMayHaveChanged();
+        // Suki end - per-player view distance
         // CraftBukkit end
         this.chatVisibility = packet.chatVisibility();
         this.canChatColor = packet.chatColors();
@@ -2233,27 +2525,37 @@ public class ServerPlayer extends Player {
         return true; // Paper
     }
 
-    public void trackChunk(ChunkPos chunkPos, Packet<?> chunkDataPacket) {
+    // Suki start - per-player track and see view distance
+
+    public void trackChunk(ChunkPos chunkPos, Packet<?> chunkDataPacket, boolean concernsTracking) {
         this.connection.send(chunkDataPacket);
-        // Paper start
-        if(io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0){
-            new io.papermc.paper.event.packet.PlayerChunkLoadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+        if (concernsTracking) {
+            // Paper start
+            if (io.papermc.paper.event.packet.PlayerChunkLoadEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                new io.papermc.paper.event.packet.PlayerChunkLoadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+            }
+            // Paper end
         }
-        // Paper end
     }
 
-    public void untrackChunk(ChunkPos chunkPos) {
+    public void untrackChunk(ChunkPos chunkPos, boolean concernsTracking) {
         if (this.isAlive()) {
-            this.connection.send(new ClientboundForgetLevelChunkPacket(chunkPos.x, chunkPos.z));
-            // Paper start
-            if(io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0){
-                new io.papermc.paper.event.packet.PlayerChunkUnloadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+            if (!concernsTracking) {
+                this.connection.send(new ClientboundForgetLevelChunkPacket(chunkPos.x, chunkPos.z));
+            }
+            if (concernsTracking) {
+                // Paper start
+                if (io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0) {
+                    new io.papermc.paper.event.packet.PlayerChunkUnloadEvent(this.getBukkitEntity().getWorld().getChunkAt(chunkPos.longKey), this.getBukkitEntity()).callEvent();
+                }
+                // Paper end
             }
-            // Paper end
         }
 
     }
 
+    // Suki end - per-player track and see view distance
+
     public SectionPos getLastSectionPos() {
         return this.lastSectionPos;
     }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 4c53d20b593a734c6bb82c94f0ec51af21f3a32e..4fff2408777e1fccbe497b82d4c59b2904520f59 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -27,7 +27,6 @@ import java.util.Optional;
 import java.util.Set;
 import java.util.UUID;
 import java.util.function.Function;
-import java.util.function.Predicate;
 import javax.annotation.Nullable;
 
 import me.titaniumtown.ArrayConstants;
@@ -109,6 +108,7 @@ import org.galemc.gale.configuration.GaleGlobalConfiguration;
 import org.slf4j.Logger;
 
 // CraftBukkit start
+import com.google.common.base.Predicate;
 import java.util.stream.Collectors;
 import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.server.level.ServerLevel;
@@ -283,7 +283,7 @@ public abstract class PlayerList {
         boolean flag1 = gamerules.getBoolean(GameRules.RULE_REDUCEDDEBUGINFO);
 
         // Spigot - view distance
-        playerconnection.send(new ClientboundLoginPacket(player.getId(), worlddata.isHardcore(), player.gameMode.getGameModeForPlayer(), player.gameMode.getPreviousGameModeForPlayer(), this.server.levelKeys(), this.synchronizedRegistries, worldserver1.dimensionTypeId(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), this.getMaxPlayers(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance(), flag1, !flag, worldserver1.isDebug(), worldserver1.isFlat(), player.getLastDeathLocation())); // Paper - replace old player chunk management
+        playerconnection.send(new ClientboundLoginPacket(player.getId(), worlddata.isHardcore(), player.gameMode.getGameModeForPlayer(), player.gameMode.getPreviousGameModeForPlayer(), this.server.levelKeys(), this.synchronizedRegistries, worldserver1.dimensionTypeId(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), this.getMaxPlayers(), player.getSeeViewDistance(), worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance(), flag1, !flag, worldserver1.isDebug(), worldserver1.isFlat(), player.getLastDeathLocation())); // Paper - replace old player chunk management // Suki - per-player view distance
         player.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.send(new ClientboundUpdateEnabledFeaturesPacket(FeatureFlags.REGISTRY.toNames(worldserver1.enabledFeatures())));
         playerconnection.send(new ClientboundCustomPayloadPacket(ClientboundCustomPayloadPacket.BRAND, (new FriendlyByteBuf(Unpooled.buffer())).writeUtf(this.getServer().getServerModName())));
@@ -928,7 +928,7 @@ public abstract class PlayerList {
         // CraftBukkit start
         LevelData worlddata = worldserver1.getLevelData();
         entityplayer1.connection.send(new ClientboundRespawnPacket(worldserver1.dimensionTypeId(), worldserver1.dimension(), BiomeManager.obfuscateSeed(worldserver1.getSeed()), entityplayer1.gameMode.getGameModeForPlayer(), entityplayer1.gameMode.getPreviousGameModeForPlayer(), worldserver1.isDebug(), worldserver1.isFlat(), (byte) i, entityplayer1.getLastDeathLocation()));
-        entityplayer1.connection.send(new ClientboundSetChunkCacheRadiusPacket(worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance())); // Spigot // Paper - replace old player chunk management
+        entityplayer1.connection.send(new ClientboundSetChunkCacheRadiusPacket(entityplayer1.getSeeViewDistance())); // Spigot // Paper - replace old player chunk management // Suki - per-player see view distance
         entityplayer1.connection.send(new ClientboundSetSimulationDistancePacket(worldserver1.getChunkSource().chunkMap.playerChunkManager.getTargetTickViewDistance())); // Spigot // Paper - replace old player chunk management
         entityplayer1.spawnIn(worldserver1);
         entityplayer1.unsetRemoved();
@@ -1537,7 +1537,7 @@ public abstract class PlayerList {
             ServerLevel worldserver = (ServerLevel) iterator.next();
 
             if (worldserver != null) {
-                worldserver.getChunkSource().setViewDistance(viewDistance);
+                worldserver.getChunkSource().setVanillaWorldViewDistance(viewDistance); // Suki - per-player view distance
             }
         }
 
diff --git a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
index 3f66986948d0b43a75454389b7ec8517e2d50899..3bc6459f22ea2af7946d642b67955d249f5401f8 100644
--- a/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
+++ b/src/main/java/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
@@ -677,8 +677,8 @@ public class EnderDragon extends Mob implements Enemy {
             if (this.dragonDeathTime == 1 && !this.isSilent()) {
                 // CraftBukkit start - Use relative location for far away sounds
                 // this.world.b(1028, this.getChunkCoordinates(), 0);
-                int viewDistance = ((ServerLevel) this.level).getCraftServer().getViewDistance() * 16;
                 for (net.minecraft.server.level.ServerPlayer player : level.spigotConfig.dragonDeathSoundRadius > 0 ? ((ServerLevel) level).players() : level.getServer().getPlayerList().players) { // Paper
+                    final int viewDistance = level.sukiConfig().viewDistance.ifCanSeeButNotTracking.sendEnderDragonSpawnSound ? player.getSeeViewDistance() : player.getTrackViewDistance(); // Paper - route to player chunk loader // Suki - per-player track and see view distance
                     double deltaX = this.getX() - player.getX();
                     double deltaZ = this.getZ() - player.getZ();
                     double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
index e64389db4fef7c0f2f879ef0fc6a87ba5769a4f3..cc0401e83f74aa0f54b149792ba0174666eb34a0 100644
--- a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
+++ b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
@@ -8,6 +8,8 @@ import javax.annotation.Nullable;
 import net.minecraft.tags.BlockTags;
 import net.minecraft.tags.DamageTypeTags;
 import net.minecraft.util.Mth;
+
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.BossEvent;
 import net.minecraft.world.Difficulty;
 import net.minecraft.world.damagesource.DamageSource;
@@ -49,9 +51,7 @@ import net.minecraft.network.protocol.game.ClientboundLevelEventPacket;
 import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.network.syncher.EntityDataSerializers;
 import net.minecraft.network.syncher.SynchedEntityData;
-import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerBossEvent;
-import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.sounds.SoundEvent;
 import net.minecraft.sounds.SoundEvents;
@@ -275,8 +275,8 @@ public class WitherBoss extends Monster implements PowerableMob, RangedAttackMob
                 if (!this.isSilent()) {
                     // CraftBukkit start - Use relative location for far away sounds
                     // this.world.globalLevelEvent(1023, new BlockPosition(this), 0);
-                    int viewDistance = ((ServerLevel) this.level).getCraftServer().getViewDistance() * 16;
                     for (ServerPlayer player : level.spigotConfig.witherSpawnSoundRadius > 0 ? ((ServerLevel) level).players() : level.getServer().getPlayerList().players) { // Paper
+                        final int viewDistance = this.level.sukiConfig().viewDistance.ifCanSeeButNotTracking.sendWitherSpawnSound ? player.getSeeViewDistance() : player.getTrackViewDistance(); // Paper - route to player chunk loader // Suki - per-player track and see view distance
                         double deltaX = this.getX() - player.getX();
                         double deltaZ = this.getZ() - player.getZ();
                         double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/item/EnderEyeItem.java b/src/main/java/net/minecraft/world/item/EnderEyeItem.java
index f4fc8ff3981555e4b560289248a9b02afc04b42f..63f47d28e3292865a35295303e8db287d2aa51e0 100644
--- a/src/main/java/net/minecraft/world/item/EnderEyeItem.java
+++ b/src/main/java/net/minecraft/world/item/EnderEyeItem.java
@@ -67,9 +67,9 @@ public class EnderEyeItem extends Item {
 
                     // CraftBukkit start - Use relative location for far away sounds
                     // world.b(1038, blockposition1.c(1, 0, 1), 0);
-                    int viewDistance = world.getCraftServer().getViewDistance() * 16;
                     BlockPos soundPos = blockposition1.offset(1, 0, 1);
                     for (ServerPlayer player : world.spigotConfig.endPortalSoundRadius > 0 ? ((ServerLevel) world).players() : world.getServer().getPlayerList().players) { // Paper
+                        final int viewDistance = world.sukiConfig().viewDistance.ifCanSeeButNotTracking.sendEndPortalFillSound ? player.getSeeViewDistance() : player.getTrackViewDistance(); // Paper - apply view distance patch // Suki - per-player track and see view distance
                         double deltaX = soundPos.getX() - player.getX();
                         double deltaZ = soundPos.getZ() - player.getZ();
                         double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 42ea60e8ddb086cdad69235e4197ffbd16b0a09d..099c68a365c729b48065a91fa3c9a2cb42e4892d 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -742,7 +742,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
                 this.sendBlockUpdated(blockposition, iblockdata1, iblockdata, i);
                 // Paper start - per player view distance - allow block updates for non-ticking chunks in player view distance
                 // if copied from above
-            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((ServerLevel)this).getChunkSource().chunkMap.playerChunkManager.broadcastMap.getObjectsInRange(io.papermc.paper.util.MCUtil.getCoordinateKey(blockposition)) != null)) { // Paper - replace old player chunk management
+            } else if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && (this.isClientSide || chunk == null || ((ServerLevel)this).getChunkSource().chunkMap.playerChunkManager.getBroadcastMap(true).getObjectsInRange(io.papermc.paper.util.MCUtil.getCoordinateKey(blockposition)) != null)) { // Paper - replace old player chunk management // Suki - per-player track and see view distance
                 ((ServerLevel)this).getChunkSource().blockChanged(blockposition);
                 // Paper end - per player view distance
             }
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 8e76062dc8f9411bc2b8b76b14d21ae6aa738a3a..142052391e98ae0015920225fc1118a6b5301912 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -216,7 +216,7 @@ public class LevelChunk extends ChunkAccess {
         // this code handles the chunk sending
         if (!areNeighboursLoaded(bitsetBefore, 1) && areNeighboursLoaded(bitsetAfter, 1)) {
             // Paper start - replace old player chunk loading system
-            if (chunkMap.playerChunkManager.isChunkNearPlayers(this.chunkPos.x, this.chunkPos.z)) {
+            if (chunkMap.playerChunkManager.isChunkNearPlayers(this.chunkPos.x, this.chunkPos.z, false)) { // Suki - per-player track and see view distance
                 // the post processing is expensive, so we don't want to run it unless we're actually near
                 // a player.
                 chunkProviderServer.mainThreadProcessor.execute(() -> {
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 5e9055fdf411029ea2fed91acd6b981f79156418..4c0eb3f50d9d84670bd7cae47fce6beec899496b 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -5,6 +5,7 @@ import com.google.common.base.Predicates;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.mojang.datafixers.util.Pair;
+import io.papermc.paper.configuration.GlobalConfiguration;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
@@ -20,7 +21,6 @@ import java.util.Objects;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
-import java.util.concurrent.ExecutionException;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import net.minecraft.core.BlockPos;
@@ -114,7 +114,6 @@ import org.bukkit.entity.TippedArrow;
 import org.bukkit.entity.Trident;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.event.weather.LightningStrikeEvent;
-import org.bukkit.event.world.SpawnChangeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 import org.bukkit.generator.BiomeProvider;
 import org.bukkit.generator.BlockPopulator;
@@ -497,27 +496,26 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     public boolean refreshChunk(int x, int z) {
         ChunkHolder playerChunk = this.world.getChunkSource().chunkMap.getVisibleChunkIfPresent(ChunkPos.asLong(x, z));
         if (playerChunk == null) return false;
-
         // Paper start - rewrite player chunk loader
         net.minecraft.world.level.chunk.LevelChunk chunk = playerChunk.getSendingChunk();
         if (chunk == null) {
             return false;
         }
         // Paper end - rewrite player chunk loader
-                List<ServerPlayer> playersInRange = playerChunk.playerProvider.getPlayers(playerChunk.getPos(), false);
-                if (playersInRange.isEmpty()) return true; // Paper - rewrite player chunk loader
-
-                // Paper start - Anti-Xray - Bypass
-                Map<Object, ClientboundLevelChunkWithLightPacket> refreshPackets = new HashMap<>();
-                for (ServerPlayer player : playersInRange) {
-                    if (player.connection == null) continue;
-
-                    Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
-                    player.connection.send(refreshPackets.computeIfAbsent(shouldModify, s -> { // Use connection to prevent creating firing event
-                        return new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, true, (Boolean) s);
-                    }));
-                    // Paper end
-                }
+        List<ServerPlayer> playersInRange = playerChunk.playerProvider.getPlayers(playerChunk.getPos(), false, !this.getHandle().sukiConfig().viewDistance.ifCanSeeButNotTracking.sendChunkRefresh); // Suki - per-player track and see view distance
+        if (playersInRange.isEmpty()) return true;
+
+        // Paper start - Anti-Xray - Bypass
+        Map<Object, ClientboundLevelChunkWithLightPacket> refreshPackets = new HashMap<>();
+        for (ServerPlayer player : playersInRange) {
+            if (player.connection == null) continue;
+
+            Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
+            player.connection.send(refreshPackets.computeIfAbsent(shouldModify, s -> { // Use connection to prevent creating firing event
+                return new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, true, (Boolean) s);
+            }));
+            // Paper end
+        }
         // Paper - rewrite player chunk loader
 
         return true;
@@ -2273,7 +2271,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     // Spigot start
     @Override
     public int getViewDistance() {
-        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetNoTickViewDistance(); // Paper - replace old player chunk management
+        return getHandle().getChunkSource().chunkMap.getVanillaWorldViewDistance(); // Paper - replace old player chunk management // Suki - per-player view distance
     }
 
     @Override
@@ -2288,7 +2286,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
             throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
         }
         net.minecraft.server.level.ChunkMap chunkMap = getHandle().getChunkSource().chunkMap;
-        chunkMap.setViewDistance(viewDistance);
+        chunkMap.setVanillaWorldViewDistance(viewDistance); // Suki - per-player view distance
     }
 
     @Override
@@ -2312,13 +2310,11 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public int getSendViewDistance() {
-        return getHandle().getChunkSource().chunkMap.playerChunkManager.getTargetSendDistance();
+        return this.getViewDistance() - 1; // Suki - per-player view distance
     }
 
     @Override
-    public void setSendViewDistance(int viewDistance) {
-        getHandle().getChunkSource().chunkMap.playerChunkManager.setSendDistance(viewDistance);
-    }
+    public void setSendViewDistance(int viewDistance) {} // Suki - per-player view distance
     // Paper end - view distance api
 
     // Spigot start
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index eca5e6b93dd84307bf9dbadf32414d6f506e69dc..286f37a15b3cc8bc33c4fe9d85f5082e477aaf4f 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -189,24 +189,11 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     // Paper start - implement view distances
     @Override
     public int getViewDistance() {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            return chunkMap.playerChunkManager.getTargetNoTickViewDistance();
-        }
-        return data.getTargetNoTickViewDistance();
+        return this.getLoadViewDistance(); // Suki - per-player view distance
     }
 
     @Override
-    public void setViewDistance(int viewDistance) {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            throw new IllegalStateException("Player is not attached to world");
-        }
-
-        data.setTargetNoTickViewDistance(viewDistance);
-    }
+    public void setViewDistance(int viewDistance) {} // Suki - per-player view distance
 
     @Override
     public int getSimulationDistance() {
@@ -231,34 +218,36 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public int getNoTickViewDistance() {
-        return this.getViewDistance();
+        return this.getLoadViewDistance(); // Suki - per-player view distance
     }
 
     @Override
-    public void setNoTickViewDistance(int viewDistance) {
-        this.setViewDistance(viewDistance);
-    }
+    public void setNoTickViewDistance(int viewDistance) {} // Suki - per-player view distance
 
     @Override
     public int getSendViewDistance() {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            return chunkMap.playerChunkManager.getTargetSendDistance();
-        }
-        return data.getTargetSendViewDistance();
+        return this.getSeeViewDistance(); // Suki - per-player view distance
     }
 
     @Override
-    public void setSendViewDistance(int viewDistance) {
-        net.minecraft.server.level.ChunkMap chunkMap = this.getHandle().getLevel().getChunkSource().chunkMap;
-        io.papermc.paper.chunk.PlayerChunkLoader.PlayerLoaderData data = chunkMap.playerChunkManager.getData(this.getHandle());
-        if (data == null) {
-            throw new IllegalStateException("Player is not attached to world");
-        }
+    public void setSendViewDistance(int viewDistance) {} // Suki - per-player view distance
 
-        data.setTargetSendViewDistance(viewDistance);
+    // Suki start - per-player view distance
+    @Override
+    public int getTrackViewDistance() {
+        return this.getHandle().getTrackViewDistance();
+    }
+
+    @Override
+    public int getSeeViewDistance() {
+        return this.getHandle().getSeeViewDistance();
+    }
+
+    @Override
+    public int getLoadViewDistance() {
+        return this.getHandle().getLoadViewDistance();
     }
+    // Suki end - per-player view distance
     // Paper end - implement view distances
 
     public GameProfile getProfile() {
diff --git a/src/main/java/org/sucraft/suki/configuration/SukiGlobalConfiguration.java b/src/main/java/org/sucraft/suki/configuration/SukiGlobalConfiguration.java
index fbde70feef055b757717ea60f99e3856d780569a..d5c1727bf81c7f00d1cb0bf78b7c7b4fc1905754 100644
--- a/src/main/java/org/sucraft/suki/configuration/SukiGlobalConfiguration.java
+++ b/src/main/java/org/sucraft/suki/configuration/SukiGlobalConfiguration.java
@@ -4,6 +4,7 @@ package org.sucraft.suki.configuration;
 
 import io.papermc.paper.configuration.Configuration;
 import io.papermc.paper.configuration.ConfigurationPart;
+import net.minecraft.server.level.ServerPlayer;
 import org.spongepowered.configurate.objectmapping.meta.Setting;
 
 @SuppressWarnings({"CanBeFinal", "FieldCanBeLocal", "FieldMayBeFinal", "NotNullFieldNotInitialized", "InnerClassMayBeStatic"})
@@ -50,6 +51,53 @@ public class SukiGlobalConfiguration extends ConfigurationPart {
 
         public boolean allowInvalidClientViewDistance = false; // Suki start - allow invalid client view distance
 
+        // Suki start - per-player track and see view distance
+        public Track track;
+        public class Track extends TrackOrSee {
+
+            @Override
+            protected void onMaxTotalChunksChanged() {
+                ServerPlayer.maxTrackViewDistanceDueToTotalTrackedChunksMayHaveChanged();
+            }
+
+        }
+
+        public See see;
+        public class See extends TrackOrSee {
+
+            @Override
+            protected void onMaxTotalChunksChanged() {
+                ServerPlayer.maxSeeViewDistanceDueToTotalSeenChunksMayHaveChanged();
+            }
+
+        }
+
+        public abstract class TrackOrSee extends ConfigurationPart {
+
+            /**
+             * A value of -1 indicates no limit.
+             *
+             * @deprecated Because this variable should not be used:
+             * use {@link #getMaxTotalChunks()} and {@link #setMaxTotalChunks(int)} instead.
+             */
+            @Deprecated
+            public int maxTotalChunks = -1;
+
+            public int getMaxTotalChunks() {
+                return maxTotalChunks;
+            }
+
+            protected abstract void onMaxTotalChunksChanged();
+
+            public void setMaxTotalChunks(int maxTotalChunks) {
+                if (this.maxTotalChunks != maxTotalChunks) {
+                    this.maxTotalChunks = maxTotalChunks;
+                    onMaxTotalChunksChanged();
+                }
+            }
+
+        }
+
     }
 
     public GameplayMechanics gameplayMechanics;
diff --git a/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java b/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java
index 9d5214ad2092e0c2fee79e1177af3ea66ef35058..34e94e553cc0e95e746bf7359ae613d0833578de 100644
--- a/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java
+++ b/src/main/java/org/sucraft/suki/configuration/SukiWorldConfiguration.java
@@ -7,6 +7,9 @@ import io.papermc.paper.configuration.Configuration;
 import io.papermc.paper.configuration.ConfigurationPart;
 import io.papermc.paper.configuration.PaperConfigurations;
 import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.slf4j.Logger;
 import org.spigotmc.SpigotWorldConfig;
 import org.spongepowered.configurate.objectmapping.meta.Setting;
@@ -194,4 +197,156 @@ public class SukiWorldConfiguration extends ConfigurationPart {
 
     }
 
+    // Suki start - per-player view distance
+
+    public ViewDistance viewDistance;
+    public class ViewDistance extends ConfigurationPart {
+
+        public Track track;
+        public class Track extends UpdateAllPlayersOnChangeViewDistance {
+
+            @Override
+            protected void updatePlayer(ServerPlayer player) {
+                player.trackViewDistanceMayHaveChanged();
+            }
+
+        }
+
+        public See see;
+        public class See extends UpdateAllPlayersOnChangeViewDistance {
+
+            @Override
+            protected void updatePlayer(ServerPlayer player) {
+                player.seeViewDistanceMayHaveChanged();
+            }
+
+        }
+
+        public Load load;
+        public class Load extends UpdateAllPlayersOnChangeViewDistance {
+
+            @Override
+            protected void updatePlayer(ServerPlayer player) {
+                player.loadViewDistanceMayHaveChanged();
+            }
+
+            /**
+             * @deprecated Because this variable should not be used:
+             * use {@link #getLimitBySeeViewDistance()} and {@link #setLimitBySeeViewDistance(boolean)} instead.
+             */
+            @Deprecated
+            public boolean limitBySeeViewDistance = false;
+
+            public boolean getLimitBySeeViewDistance() {
+                return limitBySeeViewDistance;
+            }
+
+            public void setLimitBySeeViewDistance(boolean limitBySeeViewDistance) {
+                this.limitBySeeViewDistance = limitBySeeViewDistance;
+                updateAllPlayers();
+            }
+
+            /**
+             * Given in ticks.
+             * <br>
+             * A value <= 0 disables this feature.
+             */
+            public transient int printLoadedChunksInterval = -1;
+
+        }
+
+        public abstract class UpdateAllPlayersOnChangeViewDistance extends SpecificDistance {
+
+            protected abstract void updatePlayer(ServerPlayer player);
+
+            protected void updateAllPlayers() {
+                Bukkit.getOnlinePlayers().forEach(player -> updatePlayer(((CraftPlayer) player).getHandle()));
+            }
+
+            @Override
+            protected void onMaxChanged() {
+                updateAllPlayers();
+            }
+
+            @Override
+            protected void onLimitByClientViewDistanceChanged() {
+                updateAllPlayers();
+            }
+
+        }
+
+        public abstract class SpecificDistance extends ConfigurationPart {
+
+            /**
+             * @deprecated Because this variable should not be used:
+             * use {@link #getPerPlayer()} instead.
+             */
+            @Deprecated
+            public boolean perPlayer = false;
+
+            public boolean getPerPlayer() {
+                return perPlayer;
+            }
+
+            /**
+             * This is only used if {@link #perPlayer} is true.
+             * <br>
+             * A value of -1 indicates no limit (it is still limited by the Bukkit world view distance).
+             * <br>
+             * Valid values are -1,
+             * or an integer in the range [2, 32] for the track and see view distances and in the range [3, 33] for the
+             * load view distance.
+             *
+             * @deprecated Because this variable should not be used:
+             * use {@link #getMax()} and {@link #setMax(int)} instead.
+             */
+            @Deprecated
+            public int max = -1;
+
+            public int getMax() {
+                return max;
+            }
+
+            protected abstract void onMaxChanged();
+
+            public void setMax(int max) {
+                this.max = max;
+                onMaxChanged();
+            }
+
+            /**
+             * @deprecated Because this variable should not be used:
+             * use {@link #getLimitByClientViewDistance()} and {@link #setLimitByClientViewDistance(boolean)} instead.
+             */
+            @Deprecated
+            public boolean limitByClientViewDistance = false;
+
+            public boolean getLimitByClientViewDistance() {
+                return limitByClientViewDistance;
+            }
+
+            protected abstract void onLimitByClientViewDistanceChanged();
+
+            public void setLimitByClientViewDistance(boolean limitByClientViewDistance) {
+                this.limitByClientViewDistance = limitByClientViewDistance;
+                onLimitByClientViewDistanceChanged();
+            }
+
+        }
+
+        public IfCanSeeButNotTracking ifCanSeeButNotTracking;
+
+        public class IfCanSeeButNotTracking extends ConfigurationPart {
+
+            public boolean sendChunkRefresh = true;
+            public boolean sendWitherSpawnSound = true;
+            public boolean sendEnderDragonSpawnSound = true;
+            public boolean sendEndPortalFillSound = true;
+            
+        }
+
+    }
+
+    // Suki end - per-player view distance
+
 }
