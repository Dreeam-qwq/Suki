From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MartijnMuijsers <martijnmuijsers@live.nl>
Date: Thu, 9 Jun 2022 01:17:32 +0200
Subject: [PATCH] Network-constrained chunk sending


diff --git a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
index a7e73ee9eb69774e40a5f878a174e790e509b0a1..53e8754f932ea8fbdc8a82df863df75771c4bc77 100644
--- a/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
+++ b/src/main/java/io/papermc/paper/chunk/PlayerChunkLoader.java
@@ -25,7 +25,9 @@ import org.bukkit.entity.Player;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
+import java.util.NoSuchElementException;
 import java.util.TreeSet;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -112,26 +114,35 @@ public final class PlayerChunkLoader {
         return Integer.compare(System.identityHashCode(p1), System.identityHashCode(p2));
     });
 
-    protected final TreeSet<PlayerLoaderData> chunkSendWaitQueue = new TreeSet<>((final PlayerLoaderData p1, final PlayerLoaderData p2) -> {
-        if (p1 == p2) {
-            return 0;
-        }
+    // Suki start - network-constrained chunk sending
 
-        final int timeCompare = Long.compare(p1.nextChunkSendTarget, p2.nextChunkSendTarget);
-        if (timeCompare != 0) {
-            return timeCompare;
-        }
+    protected TreeSet<PlayerLoaderData> createSendWaitQueue() {
+        return new TreeSet<>((final PlayerLoaderData p1, final PlayerLoaderData p2) -> {
+            if (p1 == p2) {
+                return 0;
+            }
 
-        final int idCompare = Integer.compare(p1.player.getId(), p2.player.getId());
+            final int timeCompare = Long.compare(p1.nextChunkSendTarget, p2.nextChunkSendTarget);
+            if (timeCompare != 0) {
+                return timeCompare;
+            }
 
-        if (idCompare != 0) {
-            return idCompare;
-        }
+            final int idCompare = Integer.compare(p1.player.getId(), p2.player.getId());
 
-        // last resort
-        return Integer.compare(System.identityHashCode(p1), System.identityHashCode(p2));
-    });
+            if (idCompare != 0) {
+                return idCompare;
+            }
 
+            // last resort
+            return Integer.compare(System.identityHashCode(p1), System.identityHashCode(p2));
+        });
+    }
+
+    protected final TreeSet<PlayerLoaderData> transmittingWaitQueue = createSendWaitQueue();
+
+    protected final TreeSet<PlayerLoaderData> chunkSendWaitQueue = createSendWaitQueue();
+
+    // Suki end - network-constrained chunk sending
 
     // no throttling is applied below this VD for loading
 
@@ -522,6 +533,7 @@ public final class PlayerChunkLoader {
         loaderData.remove();
         this.chunkLoadQueue.remove(loaderData);
         this.chunkSendQueue.remove(loaderData);
+        this.transmittingWaitQueue.remove(loaderData);
         this.chunkSendWaitQueue.remove(loaderData);
         synchronized (this.sendingChunkCounts) {
             final int count = this.sendingChunkCounts.removeInt(loaderData);
@@ -562,6 +574,32 @@ public final class PlayerChunkLoader {
         if (time < nextChunkSend) {
             return;
         }
+        // Suki start - network-constrained chunk sending
+        // drain entries from busy transmitting wait queue
+        Iterator<PlayerLoaderData> transmittingWaitQueueIterator = this.transmittingWaitQueue.iterator();
+        while (transmittingWaitQueueIterator.hasNext()) {
+            PlayerLoaderData data = transmittingWaitQueueIterator.next();
+            ChunkPriorityHolder firstQueuedSend;
+            try {
+                firstQueuedSend = data.getSendQueue(true).first();
+            } catch (NoSuchElementException e){
+                firstQueuedSend = null;
+            }
+            if (firstQueuedSend == null) {
+                try {
+                    firstQueuedSend = data.getSendQueue(false).first();
+                } catch (NoSuchElementException e) {
+                    firstQueuedSend = null;
+                }
+            }
+            if (firstQueuedSend != null) {
+                if (data.player.canSendChunkInitializationPacketNow(new ChunkPos(firstQueuedSend.chunkX, firstQueuedSend.chunkZ))) {
+                    transmittingWaitQueueIterator.remove();
+                    this.chunkSendWaitQueue.add(data);
+                }
+            }
+        }
+        // Suki end - network-constrained chunk sending
         // drain entries from wait queue
         while (!this.chunkSendWaitQueue.isEmpty()) {
             final PlayerLoaderData data = this.chunkSendWaitQueue.first();
@@ -599,13 +637,25 @@ public final class PlayerChunkLoader {
             final PlayerLoaderData data = this.chunkSendQueue.removeFirst();
 
             // Suki start - per-player track and see view distance
-            ChunkPriorityHolder queuedSend = data.getSendQueue(true).pollFirst();
+
+            ChunkPriorityHolder queuedSend;
+            try {
+                queuedSend = data.getSendQueue(true).pollFirst();
+            } catch (NoSuchElementException e){
+                queuedSend = null;
+            }
             boolean concernsTracking = true;
             if (queuedSend == null) {
-                queuedSend = data.getSendQueue(false).pollFirst();
+                try {
+                    queuedSend = data.getSendQueue(false).pollFirst();
+                } catch (NoSuchElementException e) {
+                    queuedSend = null;
+                }
                 concernsTracking = false;
             }
+
             // Suki end - per-player track and see view distance
+
             if (queuedSend == null) {
                 concurrentChunkSends.getAndDecrement(); // we never sent, so decrease
                 // stop iterating over players who have nothing to send
@@ -621,7 +671,7 @@ public final class PlayerChunkLoader {
             }
 
             data.nextChunkSendTarget = nextPlayerDeadline;
-            this.chunkSendWaitQueue.add(data);
+            this.transmittingWaitQueue.add(data);
 
             synchronized (this.sendingChunkCounts) {
                 this.sendingChunkCounts.addTo(data, 1);
@@ -1020,6 +1070,7 @@ public final class PlayerChunkLoader {
         }
 
         public void update() {
+            this.player.removeOverdueChunkInitializationPacketsInTransit(); // Suki - network-constrained chunk sending
             // Suki start - per-player view distance
             this.player.level.timings.playerChunkLoaderUpdate.startTiming();
             final int loadViewDistance = this.player.getLoadViewDistance();
@@ -1041,7 +1092,7 @@ public final class PlayerChunkLoader {
                     this.player.getAbilities().flying);
 
             // make sure we're in the send queue
-            this.loader.chunkSendWaitQueue.add(this);
+            this.loader.transmittingWaitQueue.add(this);
 
             if (
                 // has view distance stayed the same?
diff --git a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
index 5038a4bc25ae67f9cf6cd4c01c6a7cc9355850af..42e553a04deaff73d7d6630aedca4ceb84dedea7 100644
--- a/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/GlobalConfiguration.java
@@ -310,6 +310,33 @@ public class GlobalConfiguration extends ConfigurationPart {
 
     // Suki end - per-player track and see view distance
 
+    // Suki start - network-constrained chunk sending
+
+    public NetworkConstrainedChunkSending networkConstrainedChunkSending;
+
+    public class NetworkConstrainedChunkSending extends ConfigurationPart {
+
+        public MaxChunkPacketsInTransit maxChunkPacketsInTransit;
+
+        public class MaxChunkPacketsInTransit extends ConfigurationPart {
+            public int initial = 8;
+        }
+
+        /**
+         * In milliseconds
+         * A nonpositive value disables this feature
+         */
+        public int assumePacketsInTransitArrivedAfterTime = -1;
+
+        /**
+         * A negative value disables this feature
+         */
+        public int ignoreNetworkConditionsForChunksWithinChessboardDistance = -1;
+
+    }
+
+    // Suki end - network-constrained chunk sending
+
     public Messages messages;
 
     public class Messages extends ConfigurationPart {
diff --git a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
index d2c5c0afabf931fc41fe4da71a043bf5166bb9f0..246182d188f7695e39ad4dc2dbefc7a5f0403d36 100644
--- a/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
+++ b/src/main/java/io/papermc/paper/configuration/WorldConfiguration.java
@@ -281,6 +281,28 @@ public class WorldConfiguration extends ConfigurationPart {
 
     // Suki end - per-player view distance
 
+    // Suki start - network-constrained chunk sending
+
+    public NetworkConstrainedChunkSending networkConstrainedChunkSending;
+
+    public class NetworkConstrainedChunkSending extends ConfigurationPart {
+
+        public MaxChunkPacketsInTransit maxChunkPacketsInTransit;
+
+        public class MaxChunkPacketsInTransit extends ConfigurationPart {
+
+            public int min = 8;
+
+            public int max = 8;
+
+            public double targetPlayerChunkSendRateMarginFactor = 1.5;
+
+        }
+
+    }
+
+    // Suki end - network-constrained chunk sending
+
     public Anticheat anticheat;
 
     public class Anticheat extends ConfigurationPart {
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 1e853a5ceec97c0edef3950f7300622dd8b8b758..0026ff47f3193b433074abfaec9f1e279bd655ab 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -538,6 +538,100 @@ public class ServerPlayer extends Player {
     public final com.destroystokyo.paper.util.PooledHashSets.PooledObjectLinkedOpenHashSet<ServerPlayer> cachedSingleMobDistanceMap;
     // Paper end
 
+    // Suki start - network-constrained chunk sending
+
+    private static class ChunkPacketInTransit {
+
+        final long keepaliveId;
+        final long sentTimestamp;
+
+        ChunkPacketInTransit(long keepaliveId, long sentTimestamp) {
+            this.keepaliveId = keepaliveId;
+            this.sentTimestamp = sentTimestamp;
+        }
+
+    }
+
+    private final Object networkConstrainedSendingLock = new Object();
+
+    private int maxNumberOfChunkPacketsInTransitBasedOnConnection = GlobalConfiguration.get().networkConstrainedChunkSending.maxChunkPacketsInTransit.initial;
+    // Keep track of chunk packets in transit
+    private final ArrayDeque<ChunkPacketInTransit> chunkInitializationPacketsInTransitKeepaliveIds = new ArrayDeque<>();
+
+    public int getMaxNumberOfChunkPacketsInTransitBasedOnConnection() {
+        synchronized (this.networkConstrainedSendingLock) {
+            return this.maxNumberOfChunkPacketsInTransitBasedOnConnection;
+        }
+    }
+
+    public void setMaxNumberOfChunkPacketsInTransitBasedOnConnection(int maxNumberOfChunkPacketsInTransitBasedOnConnection) {
+        synchronized (this.networkConstrainedSendingLock) {
+            this.maxNumberOfChunkPacketsInTransitBasedOnConnection = maxNumberOfChunkPacketsInTransitBasedOnConnection;
+        }
+    }
+
+    private void addChunkInitializationPacketInTransit(long keepaliveId) {
+        ChunkPacketInTransit packet = new ChunkPacketInTransit(keepaliveId, System.currentTimeMillis());
+        synchronized (this.networkConstrainedSendingLock) {
+            this.chunkInitializationPacketsInTransitKeepaliveIds.addLast(packet);
+        }
+    }
+
+    public void removeOverdueChunkInitializationPacketsInTransit() {
+        if (GlobalConfiguration.get().networkConstrainedChunkSending.assumePacketsInTransitArrivedAfterTime <= 0) return;
+        synchronized (this.networkConstrainedSendingLock) {
+            while (!chunkInitializationPacketsInTransitKeepaliveIds.isEmpty()) {
+                if (chunkInitializationPacketsInTransitKeepaliveIds.peekFirst().sentTimestamp < System.currentTimeMillis() - GlobalConfiguration.get().networkConstrainedChunkSending.assumePacketsInTransitArrivedAfterTime) {
+                    chunkInitializationPacketsInTransitKeepaliveIds.pollFirst();
+                } else {
+                    break;
+                }
+            }
+        }
+    }
+
+    /**
+     * @return If this keepalive id was recognized as a fake one sent after a chunk initialization
+     */
+    public boolean removePacketsInTransitUpToKeepaliveId(long keepaliveId) {
+        synchronized (this.networkConstrainedSendingLock) {
+            if (this.chunkInitializationPacketsInTransitKeepaliveIds.stream().anyMatch(it -> it.keepaliveId == keepaliveId)) {
+                // This is a response to one of our fake keep-alive packets
+                // We will remove all chunk packets in transition up to the received one that was apparently successful
+                while (!this.chunkInitializationPacketsInTransitKeepaliveIds.isEmpty()) {
+                    if (this.chunkInitializationPacketsInTransitKeepaliveIds.peekFirst().keepaliveId == keepaliveId) {
+                        this.chunkInitializationPacketsInTransitKeepaliveIds.removeFirst();
+                        break;
+                    }
+                    this.chunkInitializationPacketsInTransitKeepaliveIds.removeFirst();
+                }
+                return true;
+            }
+        }
+        return false;
+    }
+
+    public boolean canSendChunkInitializationPacketNow(ChunkPos chunk) {
+        if (getChessboardDistanceToChunk(chunk) <= GlobalConfiguration.get().networkConstrainedChunkSending.ignoreNetworkConditionsForChunksWithinChessboardDistance) return true;
+        synchronized (this.networkConstrainedSendingLock) {
+            return this.chunkInitializationPacketsInTransitKeepaliveIds.size() < this.maxNumberOfChunkPacketsInTransitBasedOnConnection;
+        }
+    }
+
+    public void sendKeepaliveForChunkInTransit() {
+
+        // Quickly write a keepalive packet after sending a chunk
+        // Generate a keepalive challenge that is not the same as any real one (the real ones use the current system time itself)
+        long keepAliveChallenge = -System.currentTimeMillis();
+
+        Packet<?> followingKeepAlivePacket = new net.minecraft.network.protocol.game.ClientboundKeepAlivePacket(keepAliveChallenge);
+        this.addChunkInitializationPacketInTransit(keepAliveChallenge);
+        this.connection.send(followingKeepAlivePacket);
+
+    }
+
+    // Suki end - network-constrained chunk sending
+
     // CraftBukkit start
     public String displayName;
     public net.kyori.adventure.text.Component adventure$displayName; // Paper
@@ -2529,6 +2623,7 @@ public class ServerPlayer extends Player {
             }
             // Paper end
         }
+        this.sendKeepaliveForChunkInTransit(); // Suki - network-constrained chunk sending
     }
 
     public void untrackChunk(ChunkPos chunkPos, boolean concernsTracking) {
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 780e834ef6a0338f654dd16cba6e935375129380..191aff6231c8458e284c04f5f9fbf742679cd247 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -3635,12 +3635,14 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
 
     @Override
     public void handleKeepAlive(ServerboundKeepAlivePacket packet) {
+        if (player.removePacketsInTransitUpToKeepaliveId(packet.getId())) return; // Suki - network-constrained chunk sending
         // Purpur start
         if (wtf.etil.mirai.MiraiConfig.useAlternateKeepAlive) {
             long id = packet.getId();
             if (keepAlives.size() > 0 && keepAlives.contains(id)) {
                 int ping = (int) (Util.getMillis() - id);
                 player.latency = (player.latency * 3 + ping) / 4;
+                this.updateMaxNumberOfPacketsInTransitAfterLatencyUpdate(); // Suki - network-constrained chunk sending
                 keepAlives.clear(); // we got a valid response, lets roll with it and forget the rest
             }
         } else
@@ -3650,6 +3652,7 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
             int i = (int) (Util.getMillis() - this.keepAliveTime);
 
             this.player.latency = (this.player.latency * 3 + i) / 4;
+            this.updateMaxNumberOfPacketsInTransitAfterLatencyUpdate(); // Suki - network-constrained chunk sending
             this.keepAlivePending = false;
         } else if (!this.isSingleplayerOwner()) {
             // Suki start - no disconnect on late or wrong keepalive
@@ -3666,6 +3669,71 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
 
     }
 
+    // Suki start - network-constrained chunk sending
+    private void updateMaxNumberOfPacketsInTransitAfterLatencyUpdate() {
+//            // Player ping was updated: if it is too high we update the max number of chunk packets in transit
+//            // TODO turn into configuration options
+//            if (this.player.latency > 500) {
+//                // This ping is unacceptable
+//                this.player.setMaxNumberOfChunkPacketsInTransitBasedOnConnection(player.level.paperConfig().networkConstrainedChunkSending.maxChunkPacketsInTransit.min);
+//            } else {
+//                int maxNumberOfChunkPacketsInTransitChange = 0;
+//                if (this.player.latency > 330) {
+//                    // This ping is very undesired
+//                    maxNumberOfChunkPacketsInTransitChange = -2;
+//                } else if (this.player.latency > 260) {
+//                    // This ping is quite undesired
+//                    maxNumberOfChunkPacketsInTransitChange = -1;
+//                } else if (this.player.latency < 50) {
+//                    // This ping is very good
+//                    maxNumberOfChunkPacketsInTransitChange = 2;
+//                } else if (this.player.latency < 130) {
+//                    // This ping is quite good
+//                    maxNumberOfChunkPacketsInTransitChange = 1;
+//                }
+//                if (maxNumberOfChunkPacketsInTransitChange != 0) {
+//                    this.player.setMaxNumberOfChunkPacketsInTransitBasedOnConnection(Math.max(
+//                        player.level.paperConfig().networkConstrainedChunkSending.maxChunkPacketsInTransit.min,
+//                        Math.min(
+//                            player.level.paperConfig().networkConstrainedChunkSending.maxChunkPacketsInTransit.max,
+//                            this.player.getMaxNumberOfChunkPacketsInTransitBasedOnConnection() + maxNumberOfChunkPacketsInTransitChange
+//                        )
+//                    ));
+//                }
+//            }
+        // Player ping was updated:
+        // we updated the max number of chunk packets in transit,
+        // in such a way that the maximum number of chunks that can be sent is at least the configured player chunk send rate
+        // (we want the max number of chunk packets in transit to be as low as possible, but we cannot set it very low for poor ping connections,
+        // because then the chunk sending speed would become too low)
+        // For example: if the configured player chunk send rate is 50 chunks/sec, we want to set the max number of chunk packets in transit
+        // so that we can reach at least 50 chunks/sec based on that system (because we should not unnecessarily limit a setting that
+        // we have already apparently decided is good - we assume that the configured player chunk send rate is well chosen for a nice
+        // world loading speed), if we use a factor of 1.5, we should reach 75 chunks/sec in this way, and then if we have a ping of 20ms,
+        // we would be limited to 50 chunks/sec if we have a max of 1 chunk packet in transit, and 100 chunks/sec if we have a max of 2 chunk packets
+        // in transit, so we set the max number of chunk packets in transit to 2 so we are at least above the 75 chunks/sec (which is the configured
+        // player chunk send rate with a margin, that we want to be above)
+        // Note that this can lead to a very high number of chunk packets in transit for connections with very poor ping, which is not desirable,
+        // because it would overload any client suddenly due to a burst of packets, so we still do not set the max number of chunk packets in transit
+        // higher than a certain limit (like 12 or so) because we have decided at that point even poor connections still have an okay world loading speed
+        // so we don't need to boost it into levels that the client CPU/GPU can't handle
+        var level = this.player.level;
+        if (level != null) {
+            if (this.player.latency > 0) {
+                var playerChunkSendRateWithMargin = GlobalConfiguration.get().chunkLoading.targetPlayerChunkSendRate * level.paperConfig().networkConstrainedChunkSending.maxChunkPacketsInTransit.targetPlayerChunkSendRateMarginFactor;
+                var chunksPerSecondIfMaxOneChunkPacketInTransit = 1000.0 / this.player.latency;
+                this.player.setMaxNumberOfChunkPacketsInTransitBasedOnConnection(Math.max(
+                    player.level.paperConfig().networkConstrainedChunkSending.maxChunkPacketsInTransit.min,
+                    Math.min(
+                        (int) Math.ceil(playerChunkSendRateWithMargin / chunksPerSecondIfMaxOneChunkPacketInTransit),
+                        player.level.paperConfig().networkConstrainedChunkSending.maxChunkPacketsInTransit.max
+                    )
+                ));
+            }
+        }
+    }
+    // Suki end - network-constrained chunk sending
+
     @Override
     public void handlePlayerAbilities(ServerboundPlayerAbilitiesPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.getLevel());
